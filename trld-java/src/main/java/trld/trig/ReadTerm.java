/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/trig/parser.py
 */
package trld.trig;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import static trld.platform.Common.jsonEncode;
import trld.platform.Input;
import static trld.jsonld.Base.VALUE;
import static trld.jsonld.Base.TYPE;
import static trld.jsonld.Base.LANGUAGE;
import static trld.jsonld.Base.ID;
import static trld.jsonld.Base.LIST;
import static trld.jsonld.Base.GRAPH;
import static trld.jsonld.Base.CONTEXT;
import static trld.jsonld.Base.VOCAB;
import static trld.jsonld.Base.BASE;
import static trld.jsonld.Base.PREFIX;
import static trld.jsonld.Base.PREFIX_DELIMS;
import static trld.jsonld.Star.ANNOTATION;
import static trld.jsonld.Star.ANNOTATED_TYPE_KEY;
import static trld.Rdfterms.RDF_TYPE;
import static trld.Rdfterms.XSD;
import static trld.Rdfterms.XSD_DOUBLE;
import static trld.Rdfterms.XSD_INTEGER;
import static trld.trig.Parser.*;


public class ReadTerm extends BaseParserState {
  public static final String ESCAPE_CHAR = "\\";
  public List<String> collected;
  public Map<String, String> escapeChars;
  public Boolean escapeNext;
  public List<String> unicodeChars;
  public Integer unicodeEscapesLeft;

  public ReadTerm(/*@Nullable*/ ParserState parent) {
    super(parent);
    this.collected = new ArrayList<>();
    this.escapeNext = false;
    this.unicodeChars = new ArrayList<>();
    this.unicodeEscapesLeft = 0;
  }

  public void collect(String c) {
    this.collected.add(c);
  }

  public String pop() {
    String value = String.join("", this.collected);
    this.collected = new ArrayList<>();
    return value;
  }

  public boolean handleEscape(String c) {
    if (this.unicodeEscapesLeft > 0) {
      this.unicodeChars.add(c);
      if (this.unicodeEscapesLeft == 1) {
        String hexSeq = String.join("", this.unicodeChars);
        try {
          c = Character.toString(((char) Integer.valueOf(hexSeq, 16).intValue()));
        } catch (NumberFormatException e) {
          throw new NotationError("Invalid unicode escape: " + hexSeq);
        }
        this.unicodeChars = new ArrayList<>();
        this.unicodeEscapesLeft = 0;
      } else {
        this.unicodeEscapesLeft -= 1;
        return true;
      }
    } else if (this.escapeNext) {
      if ((c == null && ((Object) "u") == null || c != null && (c).equals("u"))) {
        this.unicodeEscapesLeft = 4;
        return true;
      } else if ((c == null && ((Object) "U") == null || c != null && (c).equals("U"))) {
        this.unicodeEscapesLeft = 8;
        return true;
      } else if (this.escapeChars.containsKey(c)) {
        c = (String) this.escapeChars.get(c);
      } else {
        throw new NotationError("Invalid escape char: " + c);
      }
    }
    if (this.escapeNext) {
      this.escapeNext = false;
      this.collect(c);
      return true;
    }
    if ((c == null && ((Object) this.ESCAPE_CHAR) == null || c != null && (c).equals(this.ESCAPE_CHAR))) {
      this.escapeNext = true;
      return true;
    }
    return false;
  }

  public Map.Entry<ParserState, Object> backtrack(String prevC, String c, Object value) {
    Map.Entry<ParserState, Object> state_value = this.parent.consume(prevC, value);
    ParserState state = state_value.getKey();
    value = state_value.getValue();
    return state.consume(c, value);
  }
}
