/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/trig/parser.py
 */
package trld.trig;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import static trld.platform.Common.jsonEncode;
import trld.platform.Input;
import static trld.jsonld.Base.VALUE;
import static trld.jsonld.Base.TYPE;
import static trld.jsonld.Base.LANGUAGE;
import static trld.jsonld.Base.ID;
import static trld.jsonld.Base.LIST;
import static trld.jsonld.Base.GRAPH;
import static trld.jsonld.Base.CONTEXT;
import static trld.jsonld.Base.VOCAB;
import static trld.jsonld.Base.BASE;
import static trld.jsonld.Base.PREFIX;
import static trld.jsonld.Base.PREFIX_DELIMS;
import static trld.jsonld.Star.ANNOTATION;
import static trld.jsonld.Star.ANNOTATED_TYPE_KEY;
import static trld.Rdfterms.RDF_TYPE;
import static trld.Rdfterms.XSD;
import static trld.Rdfterms.XSD_DOUBLE;
import static trld.Rdfterms.XSD_INTEGER;
import static trld.trig.Parser.*;


public class ReadNodes extends ReadNode {
  public ReadNodes(/*@Nullable*/ ParserState parent) { super(parent); };
  public List<Map> nodes;
  public Boolean expectGraph;

  public void init() {
    this.nodes = new ArrayList<>();
    this.reset();
  }

  public void reset() {
    this.node = null;
    this.p = null;
    this.lastValue = null;
    this.expectGraph = false;
  }

  public Map.Entry<ParserState, Object> consume(String c, Object prevValue) {
    if (prevValue != null) {
      if (prevValue instanceof String) {
        String prevStr = (String) prevValue;
        Boolean finalDot = false;
        if (AT_KEYWORDS.contains(prevStr)) {
          prevStr = (prevStr.length() >= 1 ? prevStr.substring(1) : "");
          finalDot = true;
        }
        if ((prevStr == null && ((Object) RQ_PREFIX) == null || prevStr != null && (prevStr).equals(RQ_PREFIX))) {
          return new ReadPrefix(this, finalDot).consume(c, null);
        } else if ((prevStr == null && ((Object) RQ_BASE) == null || prevStr != null && (prevStr).equals(RQ_BASE))) {
          return new ReadBase(this, finalDot).consume(c, null);
        } else if ((prevStr == null && ((Object) RQ_GRAPH) == null || prevStr != null && (prevStr).equals(RQ_GRAPH))) {
          this.expectGraph = true;
          return new KeyValue(this, null);
        }
        prevValue = prevStr;
      }
      if (this.node == null) {
        assert prevValue instanceof Map;
        this.node = (Map) this.nodeWithId((Map) prevValue);
      } else {
        if ((this.p == null && this.expectGraph && this.node != null)) {
          throw new NotationError("Expected graph notation to follow, got " + prevValue);
        }
        this.fillNode(prevValue);
      }
    }
    if ((c == null && ((Object) EOF) == null || c != null && (c).equals(EOF))) {
      Map<String, Object> result = Builtins.mapOf(CONTEXT, this.context, GRAPH, this.nodes);
      return new KeyValue(this.parent, result);
    } else if (((c == null && ((Object) ".") == null || c != null && (c).equals(".")) && (this.p == null || this.lastValue != null))) {
      this.nextNode();
      return new KeyValue(this, null);
    } else {
      if (this.openBrace) {
        if (!c.equals("|")) {
          this.openBrace = false;
          this.expectGraph = false;
          ReadGraph state = new ReadGraph(this);
          return state.consume(c, prevValue);
        }
      }
      return this.consumeNodeChar(c);
    }
  }

  public void nextNode() {
    if ((this.node == null || (this.p == null && (!this.node.containsKey(GRAPH) && (this.node.containsKey(ID) && this.node.size() == 1))))) {
      throw new NotationError("Incomplete triple for node: " + this.node);
    }
    this.nodes.add(this.node);
    this.reset();
  }
}
