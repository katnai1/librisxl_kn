/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/trig/parser.py
 */
package trld.trig;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import trld.Input;
import static trld.Common.dumpJson;
import static trld.jsonld.Base.VALUE;
import static trld.jsonld.Base.TYPE;
import static trld.jsonld.Base.LANGUAGE;
import static trld.jsonld.Base.ID;
import static trld.jsonld.Base.LIST;
import static trld.jsonld.Base.GRAPH;
import static trld.jsonld.Base.CONTEXT;
import static trld.jsonld.Base.VOCAB;
import static trld.jsonld.Base.BASE;
import static trld.jsonld.Base.PREFIX;
import static trld.jsonld.Base.PREFIX_DELIMS;
import static trld.Rdfterms.RDF_TYPE;
import static trld.Rdfterms.XSD;
import static trld.Rdfterms.XSD_DOUBLE;
import static trld.Rdfterms.XSD_INTEGER;
import static trld.trig.Parser.*;


public class ReadLiteral extends ReadTerm {
  public /*@Nullable*/ String value;
  public String quotechar;
  public Integer multiline;
  public Integer prevDtStart;

  public ReadLiteral(ParserState parent, String quotechar) {
    super(parent);
    this.quotechar = quotechar;
    this.escapeChars = ESC_CHARS;
  }

  public void init() {
    this.prevDtStart = 0;
    this.value = null;
    this.multiline = 0;
  }

  public Map.Entry<ParserState, Object> consume(String c, Object prevValue) {
    if (((this.value == null && ((Object) "") == null || this.value != null && (this.value).equals("")) && (c == null && ((Object) this.quotechar) == null || c != null && (c).equals(this.quotechar)))) {
      this.multiline = 1;
      this.value = null;
      return new KeyValue(this, null);
    } else if (this.value != null) {
      if (this.prevDtStart > 0) {
        this.noAfterLiteral("Datatype", prevValue);
        if ((c == null && ((Object) "^") == null || c != null && (c).equals("^"))) {
          assert this.prevDtStart == 1;
          this.prevDtStart = 2;
          return new KeyValue(this, null);
        } else {
          assert this.prevDtStart == 2;
          this.prevDtStart = 0;
          return new ReadSymbol(this).consume(c, null);
        }
      }
      if ((c == null && ((Object) "^") == null || c != null && (c).equals("^"))) {
        this.noAfterLiteral("Datatype", prevValue);
        this.prevDtStart = 1;
        return new KeyValue(this, null);
      }
      if ((c == null && ((Object) "@") == null || c != null && (c).equals("@"))) {
        this.noAfterLiteral("Language", prevValue);
        ReadLanguage state = new ReadLanguage(this);
        return new KeyValue(new ReadLanguage(this), null);
      }
      Map<String, String> value = Builtins.mapOf(VALUE, this.value);
      if (prevValue != null) {
        if ((prevValue instanceof Map && ((Map) prevValue).containsKey(LANGUAGE))) {
          value.putAll((Map) prevValue);
        } else {
          assert prevValue instanceof Map;
          value.put(TYPE, this.symbol((Map) prevValue));
        }
      }
      return this.parent.consume(c, value);
    }
    if (this.handleEscape(c)) {
      return new KeyValue(this, null);
    }
    if ((c == null && ((Object) this.quotechar) == null || c != null && (c).equals(this.quotechar))) {
      if ((this.multiline == 0 || this.multiline == 3)) {
        this.multiline = 0;
        this.value = (String) this.pop();
      } else if (this.multiline > 0) {
        this.multiline += 1;
      }
      return new KeyValue(this, null);
    }
    if (this.multiline > 1) {
      for (int i = 0; i < this.multiline - 1; i++) {
        this.collect(this.quotechar);
      }
      this.multiline = 1;
    }
    this.collect(c);
    return new KeyValue(this, null);
  }

  public void noAfterLiteral(Object kind, Object prevValue) {
    if (prevValue != null) {
      throw new NotationError(kind + " not allowed after " + prevValue);
    }
  }
}
