/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/jsonld/expansion.py
 */
package trld.jsonld;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import trld.jsonld.LoadDocumentCallback;
import static trld.platform.Common.warning;
import static trld.jsonld.Base.*;
import trld.jsonld.Context;
import trld.jsonld.Term;
import trld.jsonld.InvalidBaseDirectionError;
import trld.jsonld.InvalidNestValueError;





public class Expansion {
  public static final String EMBED = "@embed";
  public static final String EXPLICIT = "@explicit";
  public static final String OMIT_DEFAULT = "@omit_default";
  public static final String REQUIRES_ALL = "@requires_all";
  public static final Set<String> FRAMING_KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) DEFAULT, EMBED, EXPLICIT, OMIT_DEFAULT, REQUIRES_ALL})));
  public static List expand(Object docData, String baseIri) {
    return expand(docData, baseIri, null);
  }
  public static List expand(Object docData, String baseIri, /*@Nullable*/ String expandContext) {
    return expand(docData, baseIri, expandContext, false);
  }
  public static List expand(Object docData, String baseIri, /*@Nullable*/ String expandContext, Boolean ordered) {
    return expand(docData, baseIri, expandContext, ordered, null);
  }
  public static List expand(Object docData, String baseIri, /*@Nullable*/ String expandContext, Boolean ordered, /*@Nullable*/ LoadDocumentCallback documentLoader) {
    Context ctx = new Context(baseIri, null, documentLoader);
    if (expandContext != null) {
      ctx = ctx.getContext(expandContext, expandContext);
    }
    /*@Nullable*/ Object result = expansion(ctx, null, docData, baseIri, false, ordered);
    if (result == null) {
      return new ArrayList<>();
    }
    if ((result instanceof Map && ((Map) result).containsKey(GRAPH) && ((Map) result).size() == 1)) {
      result = ((Map) result).get(GRAPH);
    }
    return asList(result);
  }
  public static /*@Nullable*/ Object expansion(Context activeContext, /*@Nullable*/ String activeProperty, /*@Nullable*/ Object element, String baseUrl) {
    return expansion(activeContext, activeProperty, element, baseUrl, false);
  }
  public static /*@Nullable*/ Object expansion(Context activeContext, /*@Nullable*/ String activeProperty, /*@Nullable*/ Object element, String baseUrl, Boolean frameExpansion) {
    return expansion(activeContext, activeProperty, element, baseUrl, frameExpansion, false);
  }
  public static /*@Nullable*/ Object expansion(Context activeContext, /*@Nullable*/ String activeProperty, /*@Nullable*/ Object element, String baseUrl, Boolean frameExpansion, Boolean ordered) {
    return expansion(activeContext, activeProperty, element, baseUrl, frameExpansion, ordered, false);
  }
  public static /*@Nullable*/ Object expansion(Context activeContext, /*@Nullable*/ String activeProperty, /*@Nullable*/ Object element, String baseUrl, Boolean frameExpansion, Boolean ordered, Boolean fromMap) {
    return expansion(activeContext, activeProperty, element, baseUrl, frameExpansion, ordered, fromMap, false);
  }
  public static /*@Nullable*/ Object expansion(Context activeContext, /*@Nullable*/ String activeProperty, /*@Nullable*/ Object element, String baseUrl, Boolean frameExpansion, Boolean ordered, Boolean fromMap, Boolean warnOnKeywordlikeTerms) {
    return expansion(activeContext, activeProperty, element, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, false);
  }
  public static /*@Nullable*/ Object expansion(Context activeContext, /*@Nullable*/ String activeProperty, /*@Nullable*/ Object element, String baseUrl, Boolean frameExpansion, Boolean ordered, Boolean fromMap, Boolean warnOnKeywordlikeTerms, Boolean warnOnEmptyKeys) {
    return expansion(activeContext, activeProperty, element, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, false);
  }
  public static /*@Nullable*/ Object expansion(Context activeContext, /*@Nullable*/ String activeProperty, /*@Nullable*/ Object element, String baseUrl, Boolean frameExpansion, Boolean ordered, Boolean fromMap, Boolean warnOnKeywordlikeTerms, Boolean warnOnEmptyKeys, Boolean warnOnBnodeProperties) {
    if (element == null) {
      return null;
    }
    if ((activeProperty == null && ((Object) "@default") == null || activeProperty != null && (activeProperty).equals("@default"))) {
      frameExpansion = false;
    }
    /*@Nullable*/ Context propertyScopedContext = null;
    if ((activeContext.terms.containsKey(activeProperty) && activeContext.terms.get(activeProperty).hasLocalContext)) {
      propertyScopedContext = (Context) activeContext.terms.get(activeProperty).getLocalContext(activeContext);
    }
    if (!(element instanceof Map || element instanceof List)) {
      if ((activeProperty == null || (activeProperty == null && ((Object) GRAPH) == null || activeProperty != null && (activeProperty).equals(GRAPH)))) {
        return null;
      }
      if (propertyScopedContext != null) {
        activeContext = propertyScopedContext;
      }
      return valueExpansion(activeContext, activeProperty, element);
    }
    if (element instanceof List) {
      List results = new ArrayList<>();
      for (Object item : (List) element) {
        /*@Nullable*/ Object expandedItem = expansion(activeContext, activeProperty, item, baseUrl, frameExpansion, fromMap);
        /*@Nullable*/ Term activeTerm = (/*@Nullable*/ Term) activeContext.terms.get(activeProperty);
        if ((activeTerm != null && activeTerm.container.contains(LIST) && expandedItem instanceof List)) {
          expandedItem = Builtins.mapOf(LIST, expandedItem);
        }
        if (expandedItem instanceof List) {
          results.addAll((List) expandedItem);
        } else if (expandedItem != null) {
          results.add(expandedItem);
        }
      }
      return results;
    }
    assert element instanceof Map;
    if ((!(activeContext.propagate) && activeContext.previousContext != null)) {
      Context activeContext2 = activeContext;
      if ((!(fromMap) && !(((Map) element).keySet().stream().anyMatch(k -> (activeContext2.terms.containsKey(k) && (activeContext2.terms.get(k).iri == null && ((Object) VALUE) == null || activeContext2.terms.get(k).iri != null && (activeContext2.terms.get(k).iri).equals(VALUE))))) && !((((Map) element).size() == 1 && ((Map) element).keySet().stream().anyMatch(k -> (activeContext2.expandIri(((String) k)) == null && ((Object) ID) == null || activeContext2.expandIri(((String) k)) != null && (activeContext2.expandIri(((String) k))).equals(ID))))))) {
        activeContext = (Context) activeContext.previousContext;
      }
    }
    if (propertyScopedContext != null) {
      activeContext = propertyScopedContext;
    }
    if (((Map) element).containsKey(CONTEXT)) {
      activeContext = (Context) activeContext.getContext(((Map) element).get(CONTEXT), baseUrl);
    }
    Context typeScopedContext = activeContext;
    /*@Nullable*/ List<String> values = null;
    List<String> keys = (List<String>) new ArrayList(((Map) element).keySet());
    Collections.sort(keys);
    for (String key : keys) {
      if ((typeScopedContext.expandIri(key) == null && ((Object) TYPE) == null || typeScopedContext.expandIri(key) != null && (typeScopedContext.expandIri(key)).equals(TYPE))) {
        values = (List<String>) new ArrayList(asList(((Map) element).get(key)));
        Collections.sort(values);
        for (String value : values) {
          /*@Nullable*/ Term term = (/*@Nullable*/ Term) typeScopedContext.terms.get(value);
          if ((value instanceof String && term != null && term.hasLocalContext)) {
            activeContext = term.getLocalContext(typeScopedContext, false);
          }
        }
      }
    }
    Map result = new HashMap<>();
    Map nests = new HashMap<>();
    /*@Nullable*/ String inputType = ((values != null && values.size() > 0) ? values.get(values.size() - 1) : null);
    if ((inputType != null && inputType instanceof String)) {
      inputType = (String) activeContext.expandIri((String) inputType);
    }
    expandElement(activeContext, typeScopedContext, activeProperty, (Map) element, result, nests, inputType, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties);
    if (result.containsKey(VALUE)) {
      Object resultval = (Object) result.get(VALUE);
      if ((result.keySet().stream().anyMatch(k -> !VALUE_KEYWORDS.contains(k)) || (result.containsKey(TYPE) && (result.containsKey(LANGUAGE) || result.containsKey(DIRECTION))))) {
        throw new InvalidValueObjectError();
      }
      if ((result.containsKey(TYPE) && (result.get(TYPE) == null && ((Object) JSON) == null || result.get(TYPE) != null && (result.get(TYPE)).equals(JSON)))) {
      } else if ((resultval == null || (resultval == null && ((Object) new ArrayList<>()) == null || resultval != null && (resultval).equals(new ArrayList<>())))) {
        return null;
      } else if ((!(resultval instanceof String) && result.containsKey(LANGUAGE))) {
        throw new InvalidLanguageTaggedValueError();
      } else if ((result.containsKey(TYPE) && !((result.get(TYPE) instanceof String && isIri(((String) result.get(TYPE))))))) {
        throw new InvalidTypedValueError((String) result.get(TYPE).toString());
      }
    } else if ((result.containsKey(TYPE) && !(result.get(TYPE) instanceof List))) {
      result.put(TYPE, new ArrayList<>(Arrays.asList(new Object[] {(Object) result.get(TYPE)})));
    } else if ((result.containsKey(SET) || result.containsKey(LIST))) {
      if (result.size() > 1) {
        if ((result.size() > 2 || !result.containsKey(INDEX))) {
          throw new InvalidSetOrListObjectError(result.toString());
        }
      }
      if (result.containsKey(SET)) {
        return result.get(SET);
      }
    }
    if ((result.size() == 1 && result.containsKey(LANGUAGE))) {
      return null;
    }
    if ((activeProperty == null || (activeProperty == null && ((Object) GRAPH) == null || activeProperty != null && (activeProperty).equals(GRAPH)))) {
      if (((result instanceof Map && ((Map) result).size() == 0) || (((Map) result).containsKey(VALUE) || ((Map) result).containsKey(LIST)))) {
        return null;
      } else if ((!(frameExpansion) && result.size() == 1 && result.containsKey(ID))) {
        return null;
      }
    }
    return result;
  }
  protected static void expandElement(Context activeContext, Context typeScopedContext, /*@Nullable*/ String activeProperty, Map<String, /*@Nullable*/ Object> element, Map<String, /*@Nullable*/ Object> result, Map<String, Object> nests, /*@Nullable*/ String inputType, String baseUrl) {
    expandElement(activeContext, typeScopedContext, activeProperty, element, result, nests, inputType, baseUrl, false);
  }
  protected static void expandElement(Context activeContext, Context typeScopedContext, /*@Nullable*/ String activeProperty, Map<String, /*@Nullable*/ Object> element, Map<String, /*@Nullable*/ Object> result, Map<String, Object> nests, /*@Nullable*/ String inputType, String baseUrl, Boolean frameExpansion) {
    expandElement(activeContext, typeScopedContext, activeProperty, element, result, nests, inputType, baseUrl, frameExpansion, false);
  }
  protected static void expandElement(Context activeContext, Context typeScopedContext, /*@Nullable*/ String activeProperty, Map<String, /*@Nullable*/ Object> element, Map<String, /*@Nullable*/ Object> result, Map<String, Object> nests, /*@Nullable*/ String inputType, String baseUrl, Boolean frameExpansion, Boolean ordered) {
    expandElement(activeContext, typeScopedContext, activeProperty, element, result, nests, inputType, baseUrl, frameExpansion, ordered, false);
  }
  protected static void expandElement(Context activeContext, Context typeScopedContext, /*@Nullable*/ String activeProperty, Map<String, /*@Nullable*/ Object> element, Map<String, /*@Nullable*/ Object> result, Map<String, Object> nests, /*@Nullable*/ String inputType, String baseUrl, Boolean frameExpansion, Boolean ordered, Boolean fromMap) {
    expandElement(activeContext, typeScopedContext, activeProperty, element, result, nests, inputType, baseUrl, frameExpansion, ordered, fromMap, false);
  }
  protected static void expandElement(Context activeContext, Context typeScopedContext, /*@Nullable*/ String activeProperty, Map<String, /*@Nullable*/ Object> element, Map<String, /*@Nullable*/ Object> result, Map<String, Object> nests, /*@Nullable*/ String inputType, String baseUrl, Boolean frameExpansion, Boolean ordered, Boolean fromMap, Boolean warnOnKeywordlikeTerms) {
    expandElement(activeContext, typeScopedContext, activeProperty, element, result, nests, inputType, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, false);
  }
  protected static void expandElement(Context activeContext, Context typeScopedContext, /*@Nullable*/ String activeProperty, Map<String, /*@Nullable*/ Object> element, Map<String, /*@Nullable*/ Object> result, Map<String, Object> nests, /*@Nullable*/ String inputType, String baseUrl, Boolean frameExpansion, Boolean ordered, Boolean fromMap, Boolean warnOnKeywordlikeTerms, Boolean warnOnEmptyKeys) {
    expandElement(activeContext, typeScopedContext, activeProperty, element, result, nests, inputType, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, false);
  }
  protected static void expandElement(Context activeContext, Context typeScopedContext, /*@Nullable*/ String activeProperty, Map<String, /*@Nullable*/ Object> element, Map<String, /*@Nullable*/ Object> result, Map<String, Object> nests, /*@Nullable*/ String inputType, String baseUrl, Boolean frameExpansion, Boolean ordered, Boolean fromMap, Boolean warnOnKeywordlikeTerms, Boolean warnOnEmptyKeys, Boolean warnOnBnodeProperties) {
    List<String> keys = new ArrayList(element.keySet());
    if (ordered) {
      Collections.sort(keys);
    }
    for (String key : keys) {
      /*@Nullable*/ Object value = (/*@Nullable*/ Object) element.get(key);
      /*@Nullable*/ Object expandedValue = null;
      Map<String, /*@Nullable*/ Object> expandedMap;
      List</*@Nullable*/ Object> expandedList;
      Map<String, Object> reverseMap;
      if ((key == null && ((Object) CONTEXT) == null || key != null && (key).equals(CONTEXT))) {
        continue;
      }
      /*@Nullable*/ String expandedProperty = (/*@Nullable*/ String) activeContext.expandVocabIri(key);
      if ((expandedProperty == null || (!expandedProperty.contains(":") && !KEYWORDS.contains(expandedProperty)))) {
        continue;
      }
      if (KEYWORDS.contains(expandedProperty)) {
        if ((activeProperty == null && ((Object) REVERSE) == null || activeProperty != null && (activeProperty).equals(REVERSE))) {
          throw new InvalidReversePropertyMapError();
        }
        if ((result.containsKey(expandedProperty) && !new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) INCLUDED, TYPE}))).contains(expandedProperty))) {
        }
        if ((expandedProperty == null && ((Object) ID) == null || expandedProperty != null && (expandedProperty).equals(ID))) {
          if ((!(value instanceof String) || (frameExpansion && ((value == null && ((Object) new HashMap<>()) == null || value != null && (value).equals(new HashMap<>())) || value instanceof List)))) {
            throw new InvalidIdValueError();
          }
          if (frameExpansion) {
            expandedValue = expandedList = new ArrayList<>();
            for (Object v : expandedList) {
              expandedList.add((v instanceof String ? activeContext.expandDocRelativeIri((String) v) : v));
            }
          } else {
            expandedValue = (Object) activeContext.expandDocRelativeIri((String) value);
          }
        } else if ((expandedProperty == null && ((Object) TYPE) == null || expandedProperty != null && (expandedProperty).equals(TYPE))) {
          if ((!(value instanceof String || value instanceof List) && !((frameExpansion && ((value == null && ((Object) new HashMap<>()) == null || value != null && (value).equals(new HashMap<>())) || (value instanceof Map && isIri(((String) ((Map) value).get(DEFAULT))))))))) {
            throw new InvalidTypeValueError();
          }
          if ((value instanceof Map && (value == null && ((Object) new HashMap<>()) == null || value != null && (value).equals(new HashMap<>())))) {
            expandedValue = expandedMap = (Map) value;
          } else if ((value instanceof Map && ((Map) value).containsKey(DEFAULT))) {
            expandedMap = (Map<String, Object>) Builtins.mapOf(DEFAULT, typeScopedContext.expandDocRelativeVocabIri(((String) ((Map) value).get(DEFAULT))));
          } else {
            expandedValue = expandedList = new ArrayList<>();
            for (Object v : asList(((Object) value))) {
              expandedList.add(typeScopedContext.expandDocRelativeVocabIri(((String) v)));
            }
            if (expandedList.size() == 1) {
              expandedValue = (Object) expandedList.get(0);
            }
          }
          if (result.containsKey(TYPE)) {
            expandedValue = Stream.concat(asList(result.get(TYPE)).stream(), asList(expandedValue).stream()).collect(Collectors.toList());
          }
        } else if ((expandedProperty == null && ((Object) GRAPH) == null || expandedProperty != null && (expandedProperty).equals(GRAPH))) {
          expandedValue = asList(expansion(activeContext, GRAPH, value, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties));
        } else if ((expandedProperty == null && ((Object) INCLUDED) == null || expandedProperty != null && (expandedProperty).equals(INCLUDED))) {
          if ((activeContext.processingMode == null && ((Object) JSONLD10) == null || activeContext.processingMode != null && (activeContext.processingMode).equals(JSONLD10))) {
            continue;
          }
          expandedValue = expandedList = asList(expansion(activeContext, null, value, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties));
          if (expandedList.stream().anyMatch(v -> !(v instanceof Map))) {
            throw new InvalidIncludedValueError();
          }
          if (result.containsKey(INCLUDED)) {
            List l = (List) asList(result.get(INCLUDED));
            expandedValue = Stream.concat(l.stream(), expandedList.stream()).collect(Collectors.toList());
          }
        } else if ((expandedProperty == null && ((Object) VALUE) == null || expandedProperty != null && (expandedProperty).equals(VALUE))) {
          if ((inputType == null && ((Object) JSON) == null || inputType != null && (inputType).equals(JSON))) {
            if ((activeContext.processingMode == null && ((Object) JSONLD10) == null || activeContext.processingMode != null && (activeContext.processingMode).equals(JSONLD10))) {
              throw new InvalidValueObjectValueError();
            }
            expandedValue = value;
          } else if (((!(isScalar(value)) && value != null) && !((frameExpansion && ((value == null && ((Object) new HashMap<>()) == null || value != null && (value).equals(new HashMap<>())) || (value instanceof List && ((List) value).stream().allMatch(v -> isScalar(v)))))))) {
            throw new InvalidValueObjectValueError("Unexpected value " + value);
          } else {
            expandedValue = ((Object) value);
            if (frameExpansion) {
              expandedValue = (Object) asList(expandedValue);
            }
          }
          if (expandedValue == null) {
            result.put(VALUE, null);
            continue;
          }
        } else if ((expandedProperty == null && ((Object) LANGUAGE) == null || expandedProperty != null && (expandedProperty).equals(LANGUAGE))) {
          if (!(value instanceof String)) {
            throw new InvalidLanguageTaggedStringError();
          }
          expandedValue = (String) value;
          if (!(isLangTag((String) value))) {
            warning("Language tag " + value + " is not well-formed");
          }
          if (frameExpansion) {
            expandedValue = (Object) asList(expandedValue);
          }
        } else if ((expandedProperty == null && ((Object) DIRECTION) == null || expandedProperty != null && (expandedProperty).equals(DIRECTION))) {
          if ((activeContext.processingMode == null && ((Object) JSONLD10) == null || activeContext.processingMode != null && (activeContext.processingMode).equals(JSONLD10))) {
            continue;
          }
          if ((!DIRECTIONS.contains(value) || (frameExpansion && (!value.equals(new HashMap<>()) || (value instanceof List && !(((List) value).stream().allMatch(v -> v instanceof String))))))) {
            throw new InvalidBaseDirectionError();
          }
          expandedValue = value;
          if (frameExpansion) {
            expandedValue = (Object) asList(expandedValue);
          }
        } else if ((expandedProperty == null && ((Object) INDEX) == null || expandedProperty != null && (expandedProperty).equals(INDEX))) {
          if (!(value instanceof String)) {
            throw new InvalidIndexValueError();
          }
          expandedValue = (String) value;
        } else if ((expandedProperty == null && ((Object) LIST) == null || expandedProperty != null && (expandedProperty).equals(LIST))) {
          if ((activeProperty == null || (activeProperty == null && ((Object) GRAPH) == null || activeProperty != null && (activeProperty).equals(GRAPH)))) {
            continue;
          }
          expandedValue = asList(expansion(activeContext, activeProperty, value, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties));
        } else if ((expandedProperty == null && ((Object) SET) == null || expandedProperty != null && (expandedProperty).equals(SET))) {
          expandedValue = expansion(activeContext, activeProperty, value, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties);
        } else if ((expandedProperty == null && ((Object) REVERSE) == null || expandedProperty != null && (expandedProperty).equals(REVERSE))) {
          if (!(value instanceof Map)) {
            throw new InvalidReverseValueError();
          }
          expandedMap = ((Map<String, /*@Nullable*/ Object>) expansion(activeContext, REVERSE, (Map) value, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties));
          if (expandedMap.containsKey(REVERSE)) {
            Map<String, Object> entry = ((Map<String, Object>) expandedMap.get(REVERSE));
            for (Map.Entry<String, Object> prop_item : entry.entrySet()) {
              String prop = prop_item.getKey();
              Object item = prop_item.getValue();
              addValueAsList(result, prop, item);
            }
          }
          if (expandedMap.keySet().stream().anyMatch(k -> !k.equals(REVERSE))) {
            if (!result.containsKey(REVERSE)) result.put(REVERSE, new HashMap<>());
            reverseMap = ((Map<String, Object>) result.get(REVERSE));
            for (Map.Entry<String, Object> prop_items : expandedMap.entrySet()) {
              String prop = prop_items.getKey();
              Object items = prop_items.getValue();
              for (Map<String, Object> item : ((List<Map<String, Object>>) items)) {
                if ((item instanceof Map && (((Map) item).containsKey(VALUE) || ((Map) item).containsKey(LIST)))) {
                  throw new InvalidReversePropertyValueError();
                }
                addValueAsList(reverseMap, prop, item);
              }
            }
          }
          continue;
        } else if ((expandedProperty == null && ((Object) NEST) == null || expandedProperty != null && (expandedProperty).equals(NEST))) {
          if (!nests.containsKey(key)) nests.put(key, new ArrayList<>());
          nests.get(key);
          continue;
        }
        if ((frameExpansion && FRAMING_KEYWORDS.contains(expandedProperty))) {
          expandedValue = expansion(activeContext, activeProperty, value, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties);
        }
        if (!((expandedValue == null && (expandedProperty == null && ((Object) VALUE) == null || expandedProperty != null && (expandedProperty).equals(VALUE)) && !inputType.equals(JSON)))) {
          result.put(expandedProperty, expandedValue);
        }
        continue;
      }
      /*@Nullable*/ Term keyTerm = (/*@Nullable*/ Term) activeContext.terms.get(key);
      List containerMapping = (keyTerm != null ? keyTerm.container : new ArrayList<>());
      if ((keyTerm != null && (keyTerm.typeMapping == null && ((Object) JSON) == null || keyTerm.typeMapping != null && (keyTerm.typeMapping).equals(JSON)))) {
        expandedValue = Builtins.mapOf(VALUE, value, TYPE, JSON);
      } else if ((containerMapping.contains(LANGUAGE) && value instanceof Map)) {
        expandedValue = expandedList = new ArrayList<>();
        /*@Nullable*/ String direction = (/*@Nullable*/ String) activeContext.defaultBaseDirection;
        if ((keyTerm != null && keyTerm.direction != null)) {
          direction = (String) keyTerm.direction;
        }
        List<String> languages = (List<String>) new ArrayList(((Map) value).keySet());
        if (ordered) {
          Collections.sort(languages);
        }
        for (String lang : languages) {
          List<String> langvalues = (List<String>) asList(((Map) value).get(lang));
          for (String item : langvalues) {
            if (item == null) {
              continue;
            }
            if (!(item instanceof String)) {
              throw new InvalidLanguageMapValueError();
            }
            Map<String, String> o = Builtins.mapOf(VALUE, item, LANGUAGE, lang);
            if ((!NULLS.contains(lang) && !(isLangTag(lang)))) {
              warning("Language tag " + value + " is not well-formed");
            }
            if ((NULLS.contains(lang) || (activeContext.expandIri(lang) == null && ((Object) NONE) == null || activeContext.expandIri(lang) != null && (activeContext.expandIri(lang)).equals(NONE)))) {
              o.remove(LANGUAGE);
            }
            if (!NULLS.contains(direction)) {
              o.put(DIRECTION, ((String) direction));
            }
            expandedList.add(o);
          }
        }
      } else if ((new ArrayList<>(Arrays.asList(new String[] {(String) INDEX, TYPE, ID})).stream().anyMatch(k -> containerMapping.contains(k)) && value instanceof Map)) {
        expandedValue = expandedList = new ArrayList<>();
        String indexKey = INDEX;
        if ((keyTerm != null && keyTerm.index != null)) {
          indexKey = (String) keyTerm.index;
        }
        List<String> indexes = (List<String>) new ArrayList(((Map) value).keySet());
        if (ordered) {
          Collections.sort(indexes);
        }
        for (String index : indexes) {
          Context mapContext;
          if (((containerMapping.contains(ID) || containerMapping.contains(TYPE)) && activeContext.previousContext != null)) {
            mapContext = (Context) activeContext.previousContext;
          } else {
            mapContext = activeContext;
          }
          /*@Nullable*/ Term indexTerm = (/*@Nullable*/ Term) activeContext.terms.get(index);
          if ((containerMapping.contains(TYPE) && indexTerm != null && indexTerm.hasLocalContext)) {
            mapContext = (Context) indexTerm.getLocalContext(mapContext);
          } else {
            mapContext = activeContext;
          }
          String expandedIndex = (String) ((String) activeContext.expandVocabIri(index));
          List<Map<String, Object>> indexValues = (List<Map<String, Object>>) asList(((Map) value).get(index));
          indexValues = ((List<Map<String, Object>>) expansion(mapContext, key, indexValues, baseUrl, frameExpansion, ordered, true, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties));
          for (Map<String, Object> item : indexValues) {
            if ((containerMapping.contains(GRAPH) && (!(item instanceof Map) || !((Map) item).containsKey(GRAPH)))) {
              item = (Map) Builtins.mapOf(GRAPH, asList((Map) item));
            }
            if ((containerMapping.contains(INDEX) && !indexKey.equals(INDEX) && !expandedIndex.equals(NONE))) {
              Object reexpandedIndex = valueExpansion(activeContext, indexKey, index);
              String expandedIndexKey = (String) ((String) activeContext.expandVocabIri(indexKey));
              List indexPropertyValues = new ArrayList<>(Arrays.asList(new Object[] {(Object) reexpandedIndex}));
              if (((Map) item).containsKey(expandedIndexKey)) {
                indexPropertyValues.addAll(asList(((Map) item).get(expandedIndexKey)));
              }
              ((Map) item).put(expandedIndexKey, indexPropertyValues);
              if ((item instanceof Map && ((Map) item).containsKey(VALUE) && ((Map) item).size() > 1)) {
                throw new InvalidValueObjectError();
              }
            } else if ((containerMapping.contains(INDEX) && !((Map) item).containsKey(INDEX) && !expandedIndex.equals(NONE))) {
              ((Map) item).put(INDEX, index);
            } else if ((containerMapping.contains(ID) && !((Map) item).containsKey(ID) && !expandedIndex.equals(NONE))) {
              expandedIndex = ((String) activeContext.expandDocRelativeIri(index));
              ((Map) item).put(ID, expandedIndex);
            } else if ((containerMapping.contains(TYPE) && !expandedIndex.equals(NONE))) {
              List<String> types = new ArrayList<>(Arrays.asList(new String[] {(String) expandedIndex}));
              if (((Map) item).containsKey(TYPE)) {
                types.addAll(asList(((Map) item).get(TYPE)));
              }
              ((Map) item).put(TYPE, types);
            }
            expandedList.add((Map) item);
          }
        }
      } else {
        expandedValue = expansion(activeContext, key, value, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties);
      }
      if (expandedValue == null) {
        continue;
      }
      if (containerMapping.contains(LIST)) {
        if ((!(expandedValue instanceof Map) || !((Map) expandedValue).containsKey(LIST))) {
          expandedValue = (Map) Builtins.mapOf(LIST, asList(((Object) expandedValue)));
        }
      }
      if ((containerMapping.contains(GRAPH) && !containerMapping.contains(ID) && !containerMapping.contains(INDEX))) {
        List newExpanded = new ArrayList<>();
        for (Object ev : asList(expandedValue)) {
          newExpanded.add(Builtins.mapOf(GRAPH, asList(ev)));
        }
        expandedValue = (Object) newExpanded;
      }
      if ((keyTerm != null && keyTerm.isReverseProperty)) {
        if (!result.containsKey(REVERSE)) result.put(REVERSE, new HashMap<>());
        reverseMap = ((Map<String, Object>) result.get(REVERSE));
        if (!(expandedValue instanceof List)) {
          expandedValue = new ArrayList<>(Arrays.asList(new Object[] {(Object) expandedValue}));
        }
        for (Object item : (List) expandedValue) {
          if ((item instanceof Map && (((Map) item).containsKey(VALUE) || ((Map) item).containsKey(LIST)))) {
            throw new InvalidReversePropertyValueError();
          }
          if (!reverseMap.containsKey(expandedProperty)) reverseMap.put(expandedProperty, new ArrayList<>());
          List revEntry = (List) ((List) reverseMap.get(expandedProperty));
          addValueAsList(reverseMap, expandedProperty, item);
        }
      } else {
        addValueAsList(result, expandedProperty, expandedValue);
      }
    }
    List<String> nestingKeys = new ArrayList(nests.keySet());
    if (ordered) {
      Collections.sort(nestingKeys);
    }
    for (String nestingKey : nestingKeys) {
      List<Object> nestedValues = (element.containsKey(nestingKey) ? asList(element.get(nestingKey)) : new ArrayList<>());
      for (Object nestedValue : nestedValues) {
        if ((!(nestedValue instanceof Map) || ((Map) nestedValue).keySet().stream().anyMatch(k -> (activeContext.expandIri(((String) k)) == null && ((Object) VALUE) == null || activeContext.expandIri(((String) k)) != null && (activeContext.expandIri(((String) k))).equals(VALUE))))) {
          throw new InvalidNestValueError();
        }
        expandElement(activeContext, typeScopedContext, activeProperty, (Map) nestedValue, result, nests, inputType, baseUrl, frameExpansion, ordered, fromMap, warnOnKeywordlikeTerms, warnOnEmptyKeys, warnOnBnodeProperties);
      }
    }
  }
  public static Object valueExpansion(Context activeContext, String activeProperty, Object value) {
    /*@Nullable*/ Term activeTerm = (/*@Nullable*/ Term) activeContext.terms.get(activeProperty);
    if ((activeTerm != null && (activeTerm.typeMapping == null && ((Object) ID) == null || activeTerm.typeMapping != null && (activeTerm.typeMapping).equals(ID)) && value instanceof String)) {
      return Builtins.mapOf(ID, activeContext.expandDocRelativeIri((String) value));
    }
    if ((activeTerm != null && (activeTerm.typeMapping == null && ((Object) VOCAB) == null || activeTerm.typeMapping != null && (activeTerm.typeMapping).equals(VOCAB)) && value instanceof String)) {
      return Builtins.mapOf(ID, activeContext.expandDocRelativeVocabIri((String) value));
    }
    Map<String, /*@Nullable*/ Object> result = Builtins.mapOf(VALUE, value);
    if ((activeTerm != null && !new HashSet(new ArrayList<>(Arrays.asList(new Object[] {(Object) ID, VOCAB, NONE, null}))).contains(activeTerm.typeMapping))) {
      result.put(TYPE, activeTerm.typeMapping);
    } else if (value instanceof String) {
      /*@Nullable*/ String language = (/*@Nullable*/ String) activeContext.defaultLanguage;
      if ((activeTerm != null && activeTerm.language != null)) {
        language = (NOTHING.contains(activeTerm.language) ? null : activeTerm.language);
      }
      /*@Nullable*/ String direction = (/*@Nullable*/ String) activeContext.defaultBaseDirection;
      if ((activeTerm != null && activeTerm.direction != null)) {
        direction = (NOTHING.contains(activeTerm.direction) ? null : activeTerm.direction);
      }
      if (language != null) {
        result.put(LANGUAGE, language);
      }
      if (direction != null) {
        result.put(DIRECTION, direction);
      }
    }
    return result;
  }
}
