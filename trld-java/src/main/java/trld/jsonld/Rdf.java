/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/jsonld/rdf.py
 */
package trld.jsonld;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import static trld.platform.Common.jsonEncodeCanonical;
import static trld.platform.Common.jsonDecode;
import static trld.jsonld.Base.*;
import trld.jsonld.InvalidBaseDirectionError;
import trld.jsonld.InvalidLanguageTaggedStringError;
import trld.jsonld.BNodes;
import static trld.jsonld.Flattening.makeNodeMap;
import static trld.Rdfterms.RDF_TYPE;
import static trld.Rdfterms.RDF_VALUE;
import static trld.Rdfterms.RDF_LIST;
import static trld.Rdfterms.RDF_FIRST;
import static trld.Rdfterms.RDF_REST;
import static trld.Rdfterms.RDF_NIL;
import static trld.Rdfterms.RDF_DIRECTION;
import static trld.Rdfterms.RDF_LANGUAGE;
import static trld.Rdfterms.RDF_JSON;
import static trld.Rdfterms.RDF_LANGSTRING;
import static trld.Rdfterms.XSD_BOOLEAN;
import static trld.Rdfterms.XSD_DOUBLE;
import static trld.Rdfterms.XSD_INTEGER;
import static trld.Rdfterms.XSD_STRING;
import static trld.Rdfterms.I18N;










public class Rdf {
  public static final Double MAX_INT = Math.pow(10, 21);
  public static final String COMPOUND_LITERAL = "compound-literal";
  public static final String I18N_DATATYPE = "i18n-datatype";
  public static final String USAGES = "usages";
  static String processingMode = JSONLD11;
  public static RdfDataset toRdfDataset(Object data) {
    return toRdfDataset(data, null);
  }
  public static RdfDataset toRdfDataset(Object data, /*@Nullable*/ String rdfDirection) {
    BNodes bnodes = new BNodes();
    RdfDataset dataset = new RdfDataset();
    Map<String, Map<String, Object>> nodeMap = Builtins.mapOf(DEFAULT, new HashMap<>());
    makeNodeMap(bnodes, data, nodeMap);
    jsonldToRdfDataset(nodeMap, dataset, bnodes, rdfDirection);
    return dataset;
  }
  public static void jsonldToRdfDataset(Map<String, Map<String, Object>> nodeMap, RdfDataset dataset, BNodes bnodes) {
    jsonldToRdfDataset(nodeMap, dataset, bnodes, null);
  }
  public static void jsonldToRdfDataset(Map<String, Map<String, Object>> nodeMap, RdfDataset dataset, BNodes bnodes, /*@Nullable*/ String rdfDirection) {
    for (String graphName : ((List<String>) Builtins.sorted(nodeMap.keySet()))) {
      Map graph = (Map) nodeMap.get(graphName);
      if (!((isIri(graphName) || isBlank(graphName) || (graphName == null && ((Object) DEFAULT) == null || graphName != null && (graphName).equals(DEFAULT))))) {
        continue;
      }
      RdfGraph triples;
      if ((graphName == null && ((Object) DEFAULT) == null || graphName != null && (graphName).equals(DEFAULT))) {
        triples = (RdfGraph) dataset.defaultGraph;
      } else {
        triples = new RdfGraph(graphName);
        dataset.add(triples);
      }
      for (String subject : ((Iterable<String>) Builtins.sorted(graph.keySet()))) {
        Map<String, Object> node = (Map<String, Object>) graph.get(subject);
        if (!(isIriOrBlank(subject))) {
          continue;
        }
        for (String property : ((Iterable<String>) Builtins.sorted(node.keySet()))) {
          List<Object> values = (List<Object>) asList(node.get(property));
          if ((property == null && ((Object) TYPE) == null || property != null && (property).equals(TYPE))) {
            for (Object type : values) {
              triples.add(new RdfTriple(subject, RDF_TYPE, ((String) type)));
            }
          } else if (KEYWORDS.contains(property)) {
            continue;
          } else if (isBlank(property)) {
            continue;
          } else if (!(isIriOrBlank(property))) {
            continue;
          } else {
            for (Object item : values) {
              assert item instanceof Map;
              List<RdfTriple> listTriples = new ArrayList<>();
              Object rdfObject = (Object) ((Object) objectToRdfData((Map) item, listTriples, bnodes, rdfDirection));
              listTriples.add(new RdfTriple(subject, property, rdfObject));
              for (RdfTriple triple : listTriples) {
                triples.add(triple);
              }
            }
          }
        }
      }
    }
  }
  public static /*@Nullable*/ Object objectToRdfData(Map<String, Object> item, List listTriples, BNodes bnodes) {
    return objectToRdfData(item, listTriples, bnodes, null);
  }
  public static /*@Nullable*/ Object objectToRdfData(Map<String, Object> item, List listTriples, BNodes bnodes, /*@Nullable*/ String rdfDirection) {
    if ((item.containsKey(ID) && !(isIriOrBlank(((String) item.get(ID)))))) {
      return null;
    }
    if (item.containsKey(ID)) {
      return ((String) item.get(ID));
    }
    if (item.containsKey(LIST)) {
      return listToRdfList(((List) item.get(LIST)), listTriples, bnodes, rdfDirection);
    }
    assert item.containsKey(VALUE);
    Object value = (Object) item.get(VALUE);
    /*@Nullable*/ String datatype = ((/*@Nullable*/ String) item.get(TYPE));
    if ((datatype != null && !(isIri(datatype)) && !((datatype == null && ((Object) JSON) == null || datatype != null && (datatype).equals(JSON))))) {
      return null;
    }
    if ((item.containsKey(LANGUAGE) && !(isLangTag(((String) item.get(LANGUAGE)))))) {
      return null;
    }
    if ((datatype == null && ((Object) JSON) == null || datatype != null && (datatype).equals(JSON))) {
      value = (Object) jsonEncodeCanonical(value);
      datatype = RDF_JSON;
    }
    if (value instanceof Boolean) {
      value = ((Boolean) value ? "true" : "false");
      if (datatype == null) {
        datatype = XSD_BOOLEAN;
      }
    } else if ((value instanceof Integer || value instanceof Double && ((((Double) value) % 1 > 0 || ((Double) value) >= MAX_INT) || (datatype == null && ((Object) XSD_DOUBLE) == null || datatype != null && (datatype).equals(XSD_DOUBLE))))) {
      value = (Object) value.toString();
      if (datatype == null) {
        datatype = XSD_DOUBLE;
      }
    } else if (value instanceof Integer || value instanceof Double) {
      value = (Object) value.toString();
      if (datatype == null) {
        datatype = XSD_INTEGER;
      }
    } else if (datatype == null) {
      datatype = (item.containsKey(LANGUAGE) ? RDF_LANGSTRING : XSD_STRING);
    }
    assert value instanceof String;
    /*@Nullable*/ Object literal = null;
    if ((item.containsKey(DIRECTION) && rdfDirection != null)) {
      String language = (String) ((String) item.getOrDefault(LANGUAGE, ""));
      language = (String) language.toLowerCase();
      if ((rdfDirection == null && ((Object) I18N_DATATYPE) == null || rdfDirection != null && (rdfDirection).equals(I18N_DATATYPE))) {
        datatype = I18N + language + "_" + item.get(DIRECTION);
        literal = (Object) new RdfLiteral((String) value, datatype);
      } else if ((rdfDirection == null && ((Object) COMPOUND_LITERAL) == null || rdfDirection != null && (rdfDirection).equals(COMPOUND_LITERAL))) {
        String nodeid = (String) bnodes.makeBnodeId();
        literal = (Object) nodeid;
        listTriples.add(new RdfTriple(nodeid, RDF_VALUE, new RdfLiteral((String) value)));
        if (item.containsKey(LANGUAGE)) {
          listTriples.add(new RdfTriple(nodeid, RDF_LANGUAGE, new RdfLiteral(((String) item.get(LANGUAGE)))));
        }
        listTriples.add(new RdfTriple(nodeid, RDF_DIRECTION, new RdfLiteral(((String) item.get(DIRECTION)))));
      }
    } else {
      literal = (Object) new RdfLiteral((String) value, datatype, ((/*@Nullable*/ String) item.get(LANGUAGE)));
    }
    return literal;
  }
  public static String listToRdfList(List<Map<String, Object>> l, List listTriples, BNodes bnodes) {
    return listToRdfList(l, listTriples, bnodes, null);
  }
  public static String listToRdfList(List<Map<String, Object>> l, List listTriples, BNodes bnodes, /*@Nullable*/ String rdfDirection) {
    if (l.size() == 0) {
      return RDF_NIL;
    }
    String subject = (String) bnodes.makeBnodeId();
    String first = subject;
    Integer i = 0;
    for (Map<String, Object> item : l) {
      List embeddedTriples = new ArrayList<>();
      /*@Nullable*/ Object obj = objectToRdfData(item, embeddedTriples, bnodes, rdfDirection);
      if (obj != null) {
        listTriples.add(new RdfTriple(subject, RDF_FIRST, obj));
      }
      i += 1;
      String nextSubject = (i < l.size() ? bnodes.makeBnodeId() : RDF_NIL);
      listTriples.add(new RdfTriple(subject, RDF_REST, nextSubject));
      subject = nextSubject;
      listTriples.addAll(embeddedTriples);
    }
    return (i > 0 ? first : RDF_NIL);
  }
  public static List<Map<String, Object>> toJsonld(RdfDataset dataset) {
    return toJsonld(dataset, false);
  }
  public static List<Map<String, Object>> toJsonld(RdfDataset dataset, Boolean ordered) {
    return toJsonld(dataset, ordered, null);
  }
  public static List<Map<String, Object>> toJsonld(RdfDataset dataset, Boolean ordered, /*@Nullable*/ String rdfDirection) {
    return toJsonld(dataset, ordered, rdfDirection, false);
  }
  public static List<Map<String, Object>> toJsonld(RdfDataset dataset, Boolean ordered, /*@Nullable*/ String rdfDirection, Boolean useNativeTypes) {
    return toJsonld(dataset, ordered, rdfDirection, useNativeTypes, false);
  }
  public static List<Map<String, Object>> toJsonld(RdfDataset dataset, Boolean ordered, /*@Nullable*/ String rdfDirection, Boolean useNativeTypes, Boolean useRdfType) {
    Map<String, Map<String, Object>> defaultGraph = new HashMap<>();
    Map<String, Map<String, Map<String, Object>>> graphMap = Builtins.mapOf(DEFAULT, defaultGraph);
    Map<String, Object> referencedOnce = new HashMap<>();
    Map<String, Set<String>> compoundLiteralSubjects = new HashMap<>();
    for (RdfGraph graph : dataset) {
      String name = (graph.name == null ? DEFAULT : graph.name);
      if (!graphMap.containsKey(name)) graphMap.put(name, new HashMap<>());
      graphMap.get(name);
      if (!compoundLiteralSubjects.containsKey(name)) compoundLiteralSubjects.put(name, new HashSet());
      compoundLiteralSubjects.get(name);
      if (!name.equals(DEFAULT)) {
        if (!defaultGraph.containsKey(name)) defaultGraph.put(name, Builtins.mapOf(ID, name));
        defaultGraph.get(name);
      }
      Map<String, Map<String, Object>> nodeMap = ((Map<String, Map<String, Object>>) graphMap.get(name));
      Set<String> compounds = (Set<String>) compoundLiteralSubjects.get(name);
      for (RdfTriple triple : graph.triples) {
        if (!nodeMap.containsKey(triple.s)) {
          nodeMap.put(triple.s, Builtins.mapOf(ID, triple.s));
        }
        Map<String, Object> node = (Map<String, Object>) nodeMap.get(triple.s);
        if (((rdfDirection == null && ((Object) COMPOUND_LITERAL) == null || rdfDirection != null && (rdfDirection).equals(COMPOUND_LITERAL)) && (triple.p == null && ((Object) RDF_DIRECTION) == null || triple.p != null && (triple.p).equals(RDF_DIRECTION)))) {
          compounds.add(triple.s);
        }
        if ((triple.o instanceof String && !nodeMap.containsKey(triple.o))) {
          nodeMap.put((String) triple.o, Builtins.mapOf(ID, triple.o));
        }
        if (((triple.p == null && ((Object) RDF_TYPE) == null || triple.p != null && (triple.p).equals(RDF_TYPE)) && !(useRdfType) && triple.o instanceof String)) {
          if (!node.containsKey(TYPE)) node.put(TYPE, new ArrayList<>());
          List types = (List) ((List) node.get(TYPE));
          if (!(types.stream().anyMatch(t -> (t == null && ((Object) triple.o) == null || t != null && (t).equals(triple.o))))) {
            types.add((String) triple.o);
          }
          continue;
        }
        Map<String, Object> value = toJsonldObject(triple.o, rdfDirection, useNativeTypes);
        if (!node.containsKey(triple.p)) node.put(triple.p, new ArrayList<>());
        List<Object> values = (List<Object>) ((List) node.get(triple.p));
        if (values.stream().anyMatch(v -> nodeEquals(v, value))) {
          continue;
        }
        values.add(value);
        if ((triple.o == null && ((Object) RDF_NIL) == null || triple.o != null && (triple.o).equals(RDF_NIL))) {
          Map<String, Object> obj = (Map<String, Object>) nodeMap.get(((String) triple.o));
          if (!obj.containsKey(USAGES)) obj.put(USAGES, new ArrayList<>());
          List objUsages = (List) ((List) obj.get(USAGES));
          objUsages.add(new Usage(node, triple.p, value));
        } else if (referencedOnce.containsKey(triple.o)) {
          referencedOnce.put(((String) triple.o), false);
        } else if ((triple.o instanceof String && isBlank((String) triple.o))) {
          Usage usage = new Usage(node, triple.p, value);
          referencedOnce.put((String) triple.o, usage);
        }
      }
    }
    for (Map.Entry<String, Map<String, Map<String, Object>>> name_graphObject : graphMap.entrySet()) {
      String name = name_graphObject.getKey();
      Map<String, Map<String, Object>> graphObject = name_graphObject.getValue();
      if (compoundLiteralSubjects.containsKey(name)) {
        Set<String> graphCompounds = (Set<String>) compoundLiteralSubjects.get(name);
        for (String cl : graphCompounds) {
          Object clEntry = (Object) referencedOnce.get(cl);
          if (!(clEntry instanceof Usage)) {
            continue;
          }
          Map<String, Object> cNode = (Map<String, Object>) ((Usage) clEntry).node;
          String cProperty = (String) ((Usage) clEntry).property;
          Map<String, Object> clNode = ((Map<String, Object>) graphObject.remove(cl));
          for (Object clRef : ((List) cNode.get(cProperty))) {
            assert clRef instanceof Map;
            if (!((((Map) clRef).get(ID) == null && ((Object) cl) == null || ((Map) clRef).get(ID) != null && (((Map) clRef).get(ID)).equals(cl)))) {
              continue;
            }
            ((Map) clRef).remove(ID);
            ((Map) clRef).put(VALUE, ((Map) ((List) clNode.get(RDF_VALUE)).get(0)).get(VALUE));
            if (clNode.containsKey(RDF_LANGUAGE)) {
              ((Map) clRef).put(LANGUAGE, ((Map) ((List) clNode.get(RDF_LANGUAGE)).get(0)).get(VALUE));
              if (!(isLangTag(((String) ((Map) clRef).get(LANGUAGE))))) {
                throw new InvalidLanguageTaggedStringError(((Map) clRef).get(LANGUAGE).toString());
              }
            }
            if (clNode.containsKey(RDF_DIRECTION)) {
              ((Map) clRef).put(DIRECTION, ((Map) ((List) clNode.get(RDF_DIRECTION)).get(0)).get(VALUE));
              if (!(DIRECTIONS.contains(((Map) clRef).get(DIRECTION)))) {
                throw new InvalidBaseDirectionError(((Map) clRef).get(DIRECTION).toString());
              }
            }
          }
        }
      }
      if (!graphObject.containsKey(RDF_NIL)) {
        continue;
      }
      Map<String, Object> nil = ((Map<String, Object>) graphObject.get(RDF_NIL));
      if (!nil.containsKey(USAGES)) {
        continue;
      }
      for (Usage usage : ((List<Usage>) nil.get(USAGES))) {
        Map<String, Object> unode = (Map<String, Object>) usage.node;
        String uproperty = (String) usage.property;
        Map<String, Object> head = (Map<String, Object>) usage.value;
        List listValues = new ArrayList<>();
        List listNodes = new ArrayList<>();
        while (((uproperty == null && ((Object) RDF_REST) == null || uproperty != null && (uproperty).equals(RDF_REST)) && isWellFormedList(unode))) {
          Object nodeUsage = (Object) referencedOnce.get(((String) unode.get(ID)));
          if (!(nodeUsage instanceof Usage)) {
            break;
          }
          listValues.add(((List) unode.get(RDF_FIRST)).get(0));
          listNodes.add(unode.get(ID));
          unode = ((Usage) nodeUsage).node;
          uproperty = ((Usage) nodeUsage).property;
          head = ((Usage) nodeUsage).value;
          if (isIri(((String) unode.get(ID)))) {
            break;
          }
        }
        head.remove(ID);
        Collections.reverse(listValues);
        head.put(LIST, listValues);
        for (Object nodeId : listNodes) {
          graphObject.remove(nodeId);
        }
      }
    }
    List<Map<String, Object>> result = new ArrayList<>();
    List<String> subjects = new ArrayList(defaultGraph.keySet());
    if (ordered) {
      Collections.sort(subjects);
    }
    for (String subject : subjects) {
      Map<String, Object> sNode = ((Map<String, Object>) defaultGraph.get(subject));
      if (graphMap.containsKey(subject)) {
        Map<String, Map<String, Object>> subjectGraph = (Map<String, Map<String, Object>>) graphMap.get(subject);
        List namedGraphs = new ArrayList<>();
        sNode.put(GRAPH, namedGraphs);
        List graphNames = new ArrayList(subjectGraph.keySet());
        if (ordered) {
          Collections.sort(graphNames);
        }
        for (Object graphName : graphNames) {
          Map<String, Object> named = ((Map<String, Object>) subjectGraph.get(graphName));
          if (named.containsKey(USAGES)) {
            named.remove(USAGES);
          }
          if ((!(named.size() == 1) && named.containsKey(ID))) {
            namedGraphs.add(named);
          }
        }
      }
      if (sNode.containsKey(USAGES)) {
        sNode.remove(USAGES);
      }
      if ((!(sNode.size() == 1) && sNode.containsKey(ID))) {
        result.add(sNode);
      }
    }
    return result;
  }
  public static Map<String, Object> toJsonldObject(Object value, /*@Nullable*/ String rdfDirection, Boolean useNativeTypes) {
    if (value instanceof String) {
      return Builtins.mapOf(ID, value);
    }
    RdfLiteral literal = (RdfLiteral) value;
    Map<String, Object> result = new HashMap<>();
    Object convertedValue = (Object) literal.value;
    /*@Nullable*/ String rtype = null;
    if (useNativeTypes) {
      if ((literal.datatype == null && ((Object) XSD_STRING) == null || literal.datatype != null && (literal.datatype).equals(XSD_STRING))) {
        convertedValue = (Object) literal.value;
      } else if ((literal.datatype == null && ((Object) XSD_BOOLEAN) == null || literal.datatype != null && (literal.datatype).equals(XSD_BOOLEAN))) {
        if ((literal.value == null && ((Object) "true") == null || literal.value != null && (literal.value).equals("true"))) {
          convertedValue = true;
        } else if ((literal.value == null && ((Object) "false") == null || literal.value != null && (literal.value).equals("false"))) {
          convertedValue = false;
        } else {
          rtype = XSD_BOOLEAN;
        }
      } else if (((literal.datatype == null && ((Object) XSD_INTEGER) == null || literal.datatype != null && (literal.datatype).equals(XSD_INTEGER)) && literal.value.matches("^\\d+$"))) {
        convertedValue = (Object) Integer.valueOf(literal.value);
      } else if ((literal.datatype == null && ((Object) XSD_DOUBLE) == null || literal.datatype != null && (literal.datatype).equals(XSD_DOUBLE))) {
        try {
          convertedValue = (Object) Double.parseDouble(literal.value);
        } catch (NumberFormatException e) {
        }
      } else if (!literal.datatype.equals(XSD_STRING)) {
        rtype = (String) literal.datatype;
      }
    } else if (((literal.datatype == null && ((Object) RDF_JSON) == null || literal.datatype != null && (literal.datatype).equals(RDF_JSON)) && !processingMode.equals(JSONLD10))) {
      try {
        convertedValue = ((Object) jsonDecode(literal.value));
      } catch (Exception e) {
      }
      rtype = JSON;
    } else if (((rdfDirection == null && ((Object) I18N_DATATYPE) == null || rdfDirection != null && (rdfDirection).equals(I18N_DATATYPE)) && literal.datatype != null && literal.datatype.startsWith(I18N))) {
      convertedValue = (Object) literal.value;
      String fragId = (literal.datatype.length() >= I18N.length() ? literal.datatype.substring(I18N.length()) : "");
      Integer i = (Integer) fragId.indexOf("_");
      String lang = fragId;
      String direction = "";
      if (i > -1) {
        lang = (fragId.length() >= 0 ? fragId.substring(0, i) : "");
        direction = (fragId.length() >= i + 1 ? fragId.substring(i + 1) : "");
      }
      if (lang.length() > 0) {
        result.put(LANGUAGE, lang);
      }
      if (direction.length() > 0) {
        result.put(DIRECTION, direction);
      }
    } else if (literal.language != null) {
      result.put(LANGUAGE, literal.language);
    } else if ((literal.datatype != null && !literal.datatype.equals(XSD_STRING))) {
      rtype = (String) literal.datatype;
    }
    result.put(VALUE, convertedValue);
    if (rtype != null) {
      result.put(TYPE, rtype);
    }
    return result;
  }
  public static boolean isIriOrBlank(String iri) {
    return (isIri(iri) || isBlank(iri));
  }
  public static boolean isWellFormedList(Map<String, Object> node) {
    return (isBlank(((String) node.get(ID))) && hasListWithOneItem(node, RDF_FIRST) && hasListWithOneItem(node, RDF_REST) && (node.size() == 3 || (node.size() == 4 && node.containsKey(TYPE) && (asList(node.get(TYPE)).get(0) == null && ((Object) RDF_LIST) == null || asList(node.get(TYPE)).get(0) != null && (asList(node.get(TYPE)).get(0)).equals(RDF_LIST)))));
  }
  protected static boolean hasListWithOneItem(Map<String, Object> node, Object p) {
    return (node.containsKey(p) && node.get(p) instanceof List && ((List) node.get(p)).size() == 1);
  }
}
