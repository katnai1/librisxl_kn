/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/jsonld/base.py
 */
package trld.jsonld;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;















public class Base {
  public static final Set<String> PREFIX_DELIMS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) ":", "/", "?", "#", "[", "]", "@"})));
  public static final String BASE = "@base";
  public static final String CONTAINER = "@container";
  public static final String CONTEXT = "@context";
  public static final String DIRECTION = "@direction";
  public static final String GRAPH = "@graph";
  public static final String ID = "@id";
  public static final String IMPORT = "@import";
  public static final String INCLUDED = "@included";
  public static final String INDEX = "@index";
  public static final String JSON = "@json";
  public static final String LANGUAGE = "@language";
  public static final String LIST = "@list";
  public static final String NEST = "@nest";
  public static final String NONE = "@none";
  public static final String PREFIX = "@prefix";
  public static final String PROPAGATE = "@propagate";
  public static final String PROTECTED = "@protected";
  public static final String REVERSE = "@reverse";
  public static final String SET = "@set";
  public static final String TYPE = "@type";
  public static final String VALUE = "@value";
  public static final String VERSION = "@version";
  public static final String VOCAB = "@vocab";
  public static final String ANY = "@any";
  public static final String NULL = "@null";
  public static final String DEFAULT = "@default";
  public static final Set</*@Nullable*/ String> NULLS = new HashSet(new ArrayList<>(Arrays.asList(new Object[] {(Object) null, NULL})));
  public static final Set</*@Nullable*/ String> NOTHING = new HashSet(new ArrayList<>(Arrays.asList(new Object[] {(Object) null, NULL, NONE})));
  public static final Set<String> KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) BASE, CONTAINER, CONTEXT, DIRECTION, GRAPH, ID, IMPORT, INCLUDED, INDEX, JSON, LANGUAGE, LIST, NEST, NONE, PREFIX, PROPAGATE, PROTECTED, REVERSE, SET, TYPE, VALUE, VERSION, VOCAB})));
  public static final Set<String> CONTEXT_KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) VERSION, IMPORT, BASE, VOCAB, LANGUAGE, DIRECTION, PROPAGATE, PROTECTED})));
  public static final Set<String> VALUE_KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) DIRECTION, INDEX, LANGUAGE, TYPE, VALUE})));
  public static final Set<String> CONTAINER_KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) GRAPH, ID, INDEX, LANGUAGE, LIST, SET, TYPE})));
  public static final Set<String> DIRECTIONS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) "rtl", "ltr"})));
  public static final String JSONLD10 = "json-ld-1.0";
  public static final String JSONLD11 = "json-ld-1.1";
  public static final String JSONLD_CONTEXT_RELATION = "http://www.w3.org/ns/json-ld#context";
  public static boolean isIri(/*@Nullable*/ String value) {
    return (value != null && value.contains(":") && isIriRef(value));
  }
  public static boolean isIriRef(/*@Nullable*/ String value) {
    /* ... */;
    return (value != null && !value.contains(" ") && !(isBlank(value)));
  }
  public static boolean isBlank(String value) {
    /* ... */;
    return value.startsWith("_:");
  }
  public static boolean hasKeywordForm(String s) {
    return (s.startsWith("@") && (s.length() >= 1 ? s.substring(1) : "").matches("^\\w+$"));
  }
  public static boolean isLangTag(/*@Nullable*/ String value) {
    /* ... */;
    return (value != null && value.substring(0, 0 + 1).matches("^\\w+$") && !value.contains(" "));
  }
  public static boolean isScalar(Object o) {
    return o instanceof String || o instanceof Integer || o instanceof Double || o instanceof Boolean;
  }
  public static boolean isGraphObject(Map<String, Object> o) {
    if (o.containsKey(GRAPH)) {
      if (o.containsKey(ID)) {
        if (o.containsKey(INDEX)) {
          return o.size() == 3;
        }
        return o.size() == 2;
      }
      if (o.containsKey(INDEX)) {
        return o.size() == 2;
      }
      return o.size() == 1;
    }
    return false;
  }
  public static boolean isSimpleGraphObject(Map<String, Object> o) {
    if (o.containsKey(GRAPH)) {
      return (o.containsKey(INDEX) ? o.size() == 2 : o.size() == 1);
    }
    return false;
  }
  public static void addValueAsList(Map map, String key, Object value) {
    addValue(map, key, value, true);
  }
  public static void addValue(Map map, String key, Object value) {
    addValue(map, key, value, false);
  }
  public static void addValue(Map map, String key, Object value, Boolean aslist) {
    Object existing = (Object) map.get(key);
    if ((aslist && !map.containsKey(key))) {
      map.put(key, asList(value));
    } else if (!map.containsKey(key)) {
      map.put(key, value);
    } else {
      if (!(existing instanceof List)) {
        map.put(key, new ArrayList<>(Arrays.asList(new Object[] {(Object) existing})));
      }
      if (value instanceof List) {
        ((List) map.get(key)).addAll((List) value);
      } else {
        assert map instanceof Map;
        Object values = (Object) ((Map) map).get(key);
        assert values instanceof List;
        assert value instanceof Object;
        ((List) values).add((Object) value);
      }
    }
  }
  public static List asList(Object obj) {
    return (obj instanceof List ? (List) obj : new ArrayList<>(Arrays.asList(new Object[] {(Object) obj})));
  }
  public static String relativiseIri(String base, String iri) {
    if (iri.startsWith(base + "#")) {
      return (iri.length() >= base.length() ? iri.substring(base.length()) : "");
    }
    if ((iri.contains("?") && iri.startsWith(base))) {
      return (iri.length() >= base.length() ? iri.substring(base.length()) : "");
    }
    if (!(base.endsWith("/"))) {
      Integer last = (Integer) base.lastIndexOf("/");
      base = (base.length() >= 0 ? base.substring(0, last + 1) : "");
    }
    if (iri.startsWith(base)) {
      return (iri.length() >= base.length() ? iri.substring(base.length()) : "");
    }
    String parentbase = (base.length() >= 0 ? base.substring(0, base.lastIndexOf("/")) : "");
    String leaf = (iri.length() >= iri.lastIndexOf("/") + 1 ? iri.substring(iri.lastIndexOf("/") + 1) : "");
    List<String> relativeto = new ArrayList<>();
    while ((parentbase.contains("/") && !(parentbase.endsWith(":/")))) {
      if (iri.startsWith(parentbase)) {
        relativeto.add(leaf);
        return String.join("/", relativeto);
      }
      relativeto.add("..");
      parentbase = (parentbase.length() >= 0 ? parentbase.substring(0, parentbase.lastIndexOf("/")) : "");
    }
    return iri;
  }
  public static boolean nodeEquals(Object a, Object b) {
    if (isScalar(a)) {
      return ((a.getClass() == null && ((Object) b.getClass()) == null || a.getClass() != null && (a.getClass()).equals(b.getClass())) && (a == null && ((Object) b) == null || a != null && (a).equals(b)));
    }
    if (a instanceof List) {
      if (!(b instanceof List)) {
        return false;
      }
      Integer i = 0;
      for (Object ai : (List) a) {
        if (!(nodeEquals(ai, ((List) b).get(i)))) {
          return false;
        }
        i += 1;
      }
      return true;
    } else if (a instanceof Map) {
      if (!(b instanceof Map)) {
        return false;
      }
      return ((Map) a).keySet().stream().allMatch(k -> (((Map) b).containsKey(k) && nodeEquals(((Map) a).get(k), ((Map) b).get(k))));
    } else {
      return false;
    }
  }
}
