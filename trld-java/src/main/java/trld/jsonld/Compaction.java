/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/jsonld/compaction.py
 */
package trld.jsonld;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import static trld.platform.Common.warning;
import static trld.jsonld.Base.*;
import trld.jsonld.Context;
import trld.jsonld.Term;
import trld.jsonld.InvalidNestValueError;
import static trld.jsonld.Invcontext.getInverseContext;










public class Compaction {
  public static final String PRESERVE = "@preserve";
  public static Object compact(Object context, Object docData) {
    return compact(context, docData, null);
  }
  public static Object compact(Object context, Object docData, /*@Nullable*/ String baseIri) {
    return compact(context, docData, baseIri, true);
  }
  public static Object compact(Object context, Object docData, /*@Nullable*/ String baseIri, Boolean compactArrays) {
    return compact(context, docData, baseIri, compactArrays, false);
  }
  public static Object compact(Object context, Object docData, /*@Nullable*/ String baseIri, Boolean compactArrays, Boolean ordered) {
    Context activeContext;
    if (context instanceof Context) {
      activeContext = (Context) context;
    } else {
      /*@Nullable*/ String contextUrl = (context instanceof String ? (String) context : null);
      if (context instanceof Map) {
        context = ((Map) context).get(CONTEXT);
      }
      activeContext = (Context) new Context(baseIri).getContext(((Object) context), contextUrl);
    }
    Object result = compaction(activeContext, null, docData, compactArrays, ordered);
    if (result instanceof List) {
      if (((List) result).size() == 0) {
        result = new HashMap<>();
      } else {
        result = Builtins.mapOf(iriCompaction(activeContext, GRAPH), result);
      }
    }
    return result;
  }
  public static Object compaction(Context activeContext, /*@Nullable*/ String activeProperty, Object element) {
    return compaction(activeContext, activeProperty, element, false);
  }
  public static Object compaction(Context activeContext, /*@Nullable*/ String activeProperty, Object element, Boolean compactArrays) {
    return compaction(activeContext, activeProperty, element, compactArrays, false);
  }
  public static Object compaction(Context activeContext, /*@Nullable*/ String activeProperty, Object element, Boolean compactArrays, Boolean ordered) {
    Context typeScopedContext = activeContext;
    Object result;
    Map<String, Object> resultMap;
    List<Object> resultList;
    /*@Nullable*/ Term activeTerm = (/*@Nullable*/ Term) activeContext.terms.get(activeProperty);
    List activeContainerMapping = (activeTerm != null ? activeTerm.container : new ArrayList<>());
    Object compactedItem;
    if ((element == null || isScalar(element))) {
      return element;
    }
    if (element instanceof List) {
      result = resultList = new ArrayList<>();
      for (Object item : (List) element) {
        compactedItem = compaction(activeContext, activeProperty, item, compactArrays, ordered);
        if (compactedItem != null) {
          ((List) result).add(compactedItem);
        }
      }
      if ((resultList.size() == 0 || resultList.size() > 1 || !(compactArrays) || new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) GRAPH, SET}))).contains(activeProperty) || activeContainerMapping.contains(LIST) || activeContainerMapping.contains(SET))) {
        return resultList;
      } else {
        return resultList.get(0);
      }
    }
    assert element instanceof Map;
    if ((!(activeContext.propagate) && activeContext.previousContext != null)) {
      if (!((Map) element).containsKey(VALUE)) {
        if ((!((Map) element).containsKey(ID) || ((Map) element).size() != 1)) {
          activeContext = (Context) activeContext.previousContext;
        }
      }
    }
    if ((activeTerm != null && activeTerm.hasLocalContext)) {
      activeContext = (Context) activeTerm.getLocalContext(activeContext);
    }
    if ((((Map) element).containsKey(VALUE) || ((Map) element).containsKey(ID))) {
      Object valueResult = valueCompaction(activeContext, activeTerm, (Map) element);
      if ((isScalar(valueResult) || (activeTerm != null && (activeTerm.typeMapping == null && ((Object) JSON) == null || activeTerm.typeMapping != null && (activeTerm.typeMapping).equals(JSON))))) {
        return valueResult;
      }
    }
    if ((element instanceof Map && ((Map) element).containsKey(LIST) && activeContainerMapping.contains(LIST))) {
      return compaction(activeContext, activeProperty, ((Map) element).get(LIST), compactArrays, ordered);
    }
    Boolean insideReverse = (Boolean) (activeProperty == null && ((Object) REVERSE) == null || activeProperty != null && (activeProperty).equals(REVERSE));
    result = resultMap = new HashMap<>();
    List<String> compactedTypes = new ArrayList<>();
    Context currentActiveContext = activeContext;
    if (((Map) element).containsKey(TYPE)) {
      for (Object expandedType : asList(((Map) element).get(TYPE))) {
        compactedTypes.add(iriCompaction(typeScopedContext, ((String) expandedType)));
      }
      for (Object ctype : Builtins.sorted(compactedTypes)) {
        /*@Nullable*/ Term typeterm = (/*@Nullable*/ Term) typeScopedContext.terms.get(ctype);
        if ((typeterm != null && typeterm.hasLocalContext)) {
          activeContext = typeterm.getLocalContext(currentActiveContext, false);
        }
      }
    }
    for (Map.Entry<String, Object> expandedProperty_expandedValue : ((Map<String, Object>) element).entrySet()) {
      String expandedProperty = expandedProperty_expandedValue.getKey();
      Object expandedValue = expandedProperty_expandedValue.getValue();
      /*@Nullable*/ String compactedValue = null;
      String alias = iriCompaction(activeContext, expandedProperty, expandedValue);
      /*@Nullable*/ Term aliasTerm = (/*@Nullable*/ Term) activeContext.terms.get(alias);
      List aliasContainerMapping = (aliasTerm != null ? aliasTerm.container : new ArrayList<>());
      Boolean asArray;
      if ((expandedProperty == null && ((Object) ID) == null || expandedProperty != null && (expandedProperty).equals(ID))) {
        if (expandedValue instanceof String) {
          compactedValue = shortenIri(activeContext, (String) expandedValue);
        }
        resultMap.put(alias, ((Object) compactedValue));
        continue;
      } else if ((expandedProperty == null && ((Object) TYPE) == null || expandedProperty != null && (expandedProperty).equals(TYPE))) {
        asArray = (((activeContext.processingMode == null && ((Object) JSONLD11) == null || activeContext.processingMode != null && (activeContext.processingMode).equals(JSONLD11)) && aliasContainerMapping.contains(SET)) || !(compactArrays));
        addValue(resultMap, alias, (compactedTypes.size() == 1 ? compactedTypes.get(0) : compactedTypes), asArray);
        continue;
      } else if ((expandedProperty == null && ((Object) REVERSE) == null || expandedProperty != null && (expandedProperty).equals(REVERSE))) {
        Map<String, Object> compactedMap = ((Map<String, Object>) compaction(activeContext, REVERSE, expandedValue, compactArrays, ordered));
        for (String prop : ((List<String>) new ArrayList(compactedMap.keySet()))) {
          Object value = (Object) compactedMap.get(prop);
          /*@Nullable*/ Term propTerm = (/*@Nullable*/ Term) activeContext.terms.get(prop);
          if ((propTerm != null && propTerm.isReverseProperty)) {
            asArray = (((activeContext.processingMode == null && ((Object) JSONLD11) == null || activeContext.processingMode != null && (activeContext.processingMode).equals(JSONLD11)) && propTerm.container.contains(SET)) || !(compactArrays));
            addValue(resultMap, prop, value, asArray);
            compactedMap.remove(prop);
          }
        }
        if (compactedMap.size() > 0) {
          String revAlias = iriCompaction(activeContext, REVERSE);
          resultMap.put(revAlias, compactedMap);
        }
        continue;
      } else if ((expandedProperty == null && ((Object) PRESERVE) == null || expandedProperty != null && (expandedProperty).equals(PRESERVE))) {
        if (!expandedValue.equals(new ArrayList<>())) {
          resultMap.put(PRESERVE, compaction(activeContext, activeProperty, expandedValue, compactArrays, ordered));
        }
      } else if (((expandedProperty == null && ((Object) INDEX) == null || expandedProperty != null && (expandedProperty).equals(INDEX)) && activeContainerMapping.contains(INDEX))) {
        continue;
      } else if (new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) DIRECTION, INDEX, LANGUAGE, VALUE}))).contains(expandedProperty)) {
        resultMap.put(alias, expandedValue);
        continue;
      }
      String itemActiveProperty;
      /*@Nullable*/ Term itemActiveTerm;
      Map<String, Object> nestResult;
      if ((expandedValue == null && ((Object) new ArrayList<>()) == null || expandedValue != null && (expandedValue).equals(new ArrayList<>()))) {
        itemActiveProperty = iriCompaction(activeContext, expandedProperty, expandedValue, true, insideReverse);
        itemActiveTerm = (Term) activeContext.terms.get(itemActiveProperty);
        nestResult = getNestResult(activeContext, itemActiveTerm, resultMap);
        addValueAsList(nestResult, itemActiveProperty, new ArrayList<>());
      }
      expandedValue = (Object) asList(expandedValue);
      assert expandedValue instanceof List;
      for (Object expandedItem : (List) expandedValue) {
        itemActiveProperty = iriCompaction(activeContext, expandedProperty, expandedItem, true, insideReverse);
        itemActiveTerm = (Term) activeContext.terms.get(itemActiveProperty);
        nestResult = getNestResult(activeContext, itemActiveTerm, resultMap);
        List<String> container;
        if ((itemActiveTerm != null && itemActiveTerm.container != null)) {
          container = (List<String>) itemActiveTerm.container;
        } else {
          container = new ArrayList<>();
        }
        asArray = ((container.contains(SET) || new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) GRAPH, LIST}))).contains(itemActiveProperty)) || !(compactArrays));
        Object itemToCompact = expandedItem;
        Boolean itemIsListObject = false;
        Boolean itemIsGraphObject = false;
        if (expandedItem instanceof Map) {
          if (((Map) expandedItem).containsKey(LIST)) {
            itemToCompact = ((Map) expandedItem).get(LIST);
            itemIsListObject = true;
          }
          if (isGraphObject((Map) expandedItem)) {
            itemToCompact = ((Map) expandedItem).get(GRAPH);
            itemIsGraphObject = true;
          }
        }
        compactedItem = compaction(activeContext, itemActiveProperty, itemToCompact, compactArrays, ordered);
        if (itemIsListObject) {
          assert expandedItem instanceof Map;
          if (!(compactedItem instanceof List)) {
            compactedItem = new ArrayList<>(Arrays.asList(new Object[] {(Object) compactedItem}));
          }
          if (!container.contains(LIST)) {
            compactedItem = Builtins.mapOf(iriCompaction(activeContext, LIST), compactedItem);
            assert compactedItem instanceof Map;
            if (((Map) expandedItem).containsKey(INDEX)) {
              ((Map) compactedItem).put(iriCompaction(activeContext, INDEX), ((Map) expandedItem).get(INDEX));
            }
            addValue(nestResult, itemActiveProperty, (Map) compactedItem, asArray);
            continue;
          } else if (activeProperty != null) {
            nestResult.put(itemActiveProperty, (List) compactedItem);
            continue;
          }
        }
        Map<String, Object> mapObject;
        /*@Nullable*/ String mapKey = null;
        if (itemIsGraphObject) {
          assert expandedItem instanceof Map;
          if ((container.contains(GRAPH) && container.contains(ID))) {
            if (!nestResult.containsKey(itemActiveProperty)) nestResult.put(itemActiveProperty, new HashMap<>());
            mapObject = ((Map<String, Object>) nestResult.get(itemActiveProperty));
            String idOrNone = (String) (((Map) expandedItem).containsKey(ID) ? ((String) ((Map) expandedItem).get(ID)) : NONE);
            mapKey = (String) iriCompaction(activeContext, idOrNone, null, !((Map) expandedItem).containsKey(ID));
            addValue(mapObject, mapKey, compactedItem, asArray);
          } else if ((container.contains(GRAPH) && container.contains(INDEX) && isSimpleGraphObject((Map) expandedItem))) {
            if (!nestResult.containsKey(itemActiveProperty)) nestResult.put(itemActiveProperty, new HashMap<>());
            mapObject = ((Map<String, Object>) nestResult.get(itemActiveProperty));
            String indexOrNone = (String) (((Map) expandedItem).containsKey(INDEX) ? ((String) ((Map) expandedItem).get(INDEX)) : NONE);
            mapKey = iriCompaction(activeContext, indexOrNone);
            addValue(mapObject, mapKey, compactedItem, asArray);
          } else if ((container.contains(GRAPH) && isSimpleGraphObject((Map) expandedItem))) {
            if ((compactedItem instanceof List && ((List) compactedItem).size() > 1)) {
              compactedItem = Builtins.mapOf(iriCompaction(activeContext, INCLUDED), compactedItem);
            }
            addValue(nestResult, itemActiveProperty, compactedItem, asArray);
          } else {
            compactedItem = Builtins.mapOf(iriCompaction(activeContext, GRAPH), compactedItem);
            assert compactedItem instanceof Map;
            if (((Map) expandedItem).containsKey(ID)) {
              ((Map) compactedItem).put(iriCompaction(activeContext, ID), shortenIri(activeContext, ((String) ((Map) expandedItem).get(ID))));
            }
            if (((Map) expandedItem).containsKey(INDEX)) {
              ((Map) compactedItem).put(iriCompaction(activeContext, INDEX), iriCompaction(activeContext, ((String) ((Map) expandedItem).get(INDEX))));
            }
            addValue(nestResult, itemActiveProperty, (Map) compactedItem, asArray);
          }
        } else if (((container.contains(LANGUAGE) || container.contains(INDEX) || container.contains(ID) || container.contains(TYPE)) && !container.contains(GRAPH))) {
          assert expandedItem instanceof Map;
          if (!nestResult.containsKey(itemActiveProperty)) nestResult.put(itemActiveProperty, new HashMap<>());
          mapObject = ((Map<String, Object>) nestResult.get(itemActiveProperty));
          String containerKw = (String) ((String) (container.contains(LANGUAGE) ? LANGUAGE : (container.contains(INDEX) ? INDEX : (container.contains(ID) ? ID : (container.contains(TYPE) ? TYPE : null)))));
          String containerKey = iriCompaction(activeContext, containerKw);
          String indexKey = ((itemActiveTerm != null && itemActiveTerm.index != null) ? itemActiveTerm.index : INDEX);
          if ((container.contains(LANGUAGE) && ((Map) expandedItem).containsKey(VALUE))) {
            if (compactedItem instanceof Map) {
              compactedItem = ((Map) compactedItem).get(VALUE);
            }
            mapKey = ((String) ((Map) expandedItem).get(LANGUAGE));
          } else if ((container.contains(INDEX) && (indexKey == null && ((Object) INDEX) == null || indexKey != null && (indexKey).equals(INDEX)))) {
            if ((compactedItem instanceof Map && ((Map) compactedItem).containsKey(VALUE) && ((Map) compactedItem).size() == 1)) {
              compactedItem = ((Map) compactedItem).get(VALUE);
            }
            mapKey = ((String) ((Map) expandedItem).get(INDEX));
          } else if ((container.contains(INDEX) && !indexKey.equals(INDEX))) {
            containerKey = iriCompaction(activeContext, indexKey);
            if ((compactedItem instanceof Map && ((Map) compactedItem).containsKey(containerKey))) {
              mapKey = (String) getMapKeyAndDepleteContainerKey((Map) compactedItem, containerKey, asArray);
            }
          } else if (container.contains(ID)) {
            assert compactedItem instanceof Map;
            mapKey = ((/*@Nullable*/ String) ((Map) compactedItem).remove(containerKey));
          } else if (container.contains(TYPE)) {
            assert compactedItem instanceof Map;
            if (((Map) compactedItem).containsKey(containerKey)) {
              mapKey = (String) getMapKeyAndDepleteContainerKey((Map) compactedItem, containerKey, asArray);
            }
            if (((Map) compactedItem).size() == 1) {
              for (Map.Entry<String, Object> key_idval : ((Map<String, Object>) compactedItem).entrySet()) {
                String key = key_idval.getKey();
                Object idval = key_idval.getValue();
                if ((activeContext.expandVocabIri(key) == null && ((Object) ID) == null || activeContext.expandVocabIri(key) != null && (activeContext.expandVocabIri(key)).equals(ID))) {
                  compactedItem = compaction(activeContext, itemActiveProperty, Builtins.mapOf(ID, idval));
                }
              }
            }
          }
          if (mapKey == null) {
            mapKey = iriCompaction(activeContext, NONE);
          }
          addValue(mapObject, mapKey, compactedItem, asArray);
        } else {
          addValue(nestResult, itemActiveProperty, compactedItem, asArray);
        }
      }
    }
    return result;
  }
  protected static /*@Nullable*/ String getMapKeyAndDepleteContainerKey(Map<String, Object> compactedItem, String containerKey, Boolean asArray) {
    List<String> containerKeyValues = (List<String>) asList(compactedItem.get(containerKey));
    Object keyValue = (Object) containerKeyValues.remove(0);
    if (!(keyValue instanceof String)) {
      return null;
    }
    String mapKey = (String) keyValue;
    if (compactedItem.get(containerKey) != containerKeyValues) {
      for (Object remaining : new ArrayList(containerKeyValues)) {
        addValue(compactedItem, containerKey, remaining);
      }
    }
    if ((containerKeyValues.size() == 1 && !(asArray))) {
      compactedItem.put(containerKey, containerKeyValues.get(0));
    } else if (containerKeyValues.size() == 0) {
      compactedItem.remove(containerKey);
    }
    return mapKey;
  }
  protected static Map<String, Object> getNestResult(Context activeContext, /*@Nullable*/ Term itemActiveTerm, Map<String, Object> resultMap) {
    Map<String, Object> nestResult;
    if ((itemActiveTerm != null && itemActiveTerm.nestValue != null)) {
      if ((!itemActiveTerm.nestValue.equals(NEST) && !activeContext.expandVocabIri(itemActiveTerm.nestValue).equals(NEST))) {
        throw new InvalidNestValueError(itemActiveTerm.nestValue);
      }
      if (!resultMap.containsKey(itemActiveTerm.nestValue)) {
        resultMap.put(itemActiveTerm.nestValue, new HashMap<>());
      }
      return ((Map<String, Object>) resultMap.get(itemActiveTerm.nestValue));
    } else {
      return resultMap;
    }
  }
  public static /*@Nullable*/ String maybeIriCompaction(Context activeContext, /*@Nullable*/ String iri) {
    return maybeIriCompaction(activeContext, iri, null);
  }
  public static /*@Nullable*/ String maybeIriCompaction(Context activeContext, /*@Nullable*/ String iri, /*@Nullable*/ Object value) {
    return maybeIriCompaction(activeContext, iri, value, true);
  }
  public static /*@Nullable*/ String maybeIriCompaction(Context activeContext, /*@Nullable*/ String iri, /*@Nullable*/ Object value, Boolean vocab) {
    return maybeIriCompaction(activeContext, iri, value, vocab, false);
  }
  public static /*@Nullable*/ String maybeIriCompaction(Context activeContext, /*@Nullable*/ String iri, /*@Nullable*/ Object value, Boolean vocab, Boolean reverse) {
    if (iri == null) {
      return null;
    }
    return iriCompaction(activeContext, iri, value, vocab, reverse);
  }
  public static String shortenIri(Context activeContext, String iri) {
    return iriCompaction(activeContext, iri, null, false);
  }
  public static String iriCompaction(Context activeContext, String iri) {
    return iriCompaction(activeContext, iri, null);
  }
  public static String iriCompaction(Context activeContext, String iri, /*@Nullable*/ Object value) {
    return iriCompaction(activeContext, iri, value, true);
  }
  public static String iriCompaction(Context activeContext, String iri, /*@Nullable*/ Object value, Boolean vocab) {
    return iriCompaction(activeContext, iri, value, vocab, false);
  }
  public static String iriCompaction(Context activeContext, String iri, /*@Nullable*/ Object value, Boolean vocab, Boolean reverse) {
    Map inverseContext = (Map) getInverseContext(activeContext);
    if ((vocab && inverseContext.containsKey(iri))) {
      String defaultLanguage = (activeContext.defaultLanguage != null ? activeContext.defaultLanguage : NONE);
      if (activeContext.defaultBaseDirection != null) {
        defaultLanguage = defaultLanguage + "_" + activeContext.defaultBaseDirection;
      }
      if ((value instanceof Map && ((Map) value).containsKey(PRESERVE))) {
        List values = (List) asList(((Map) value).get(PRESERVE));
        value = (Map) values.get(0);
      }
      List<String> containers = new ArrayList<>();
      String typeOrLanguage = LANGUAGE;
      String typeOrLanguageValue = NULL;
      if ((value instanceof Map && ((Map) value).containsKey(INDEX) && !((Map) value).containsKey(GRAPH))) {
        containers.add(INDEX);
        containers.add(INDEX + SET);
      }
      if (reverse) {
        typeOrLanguage = TYPE;
        typeOrLanguageValue = REVERSE;
        containers.add(SET);
      } else if ((value instanceof Map && ((Map) value).containsKey(LIST))) {
        if (!((Map) value).containsKey(INDEX)) {
          containers.add(LIST);
        }
        List<Map<String, Object>> valuelist = (List<Map<String, Object>>) ((List<Map<String, Object>>) ((Map) value).get(LIST));
        /*@Nullable*/ String commonType = null;
        /*@Nullable*/ String commonLanguage = null;
        if (valuelist.size() == 0) {
          commonLanguage = defaultLanguage;
        }
        for (Map<String, Object> item : valuelist) {
          String itemLanguage = NONE;
          String itemType = NONE;
          if ((item instanceof Map && ((Map) item).containsKey(VALUE))) {
            if (((Map) item).containsKey(DIRECTION)) {
              itemLanguage = ((String) ((Map) item).getOrDefault(LANGUAGE, "")) + "_" + ((Map) item).get(DIRECTION);
            } else if (((Map) item).containsKey(LANGUAGE)) {
              itemLanguage = ((String) ((Map) item).get(LANGUAGE));
            } else if (((Map) item).containsKey(TYPE)) {
              itemType = ((String) ((Map) item).get(TYPE));
            } else {
              itemLanguage = NULL;
            }
          } else {
            itemType = ID;
          }
          if (commonLanguage == null) {
            commonLanguage = itemLanguage;
          } else if ((!itemLanguage.equals(commonLanguage) && item instanceof Map && ((Map) item).containsKey(VALUE))) {
            commonLanguage = NONE;
          }
          if (commonType == null) {
            commonType = itemType;
          } else if (!itemType.equals(commonType)) {
            commonType = NONE;
          }
          if (((commonLanguage == null && ((Object) NONE) == null || commonLanguage != null && (commonLanguage).equals(NONE)) && (commonType == null && ((Object) NONE) == null || commonType != null && (commonType).equals(NONE)))) {
            break;
          }
        }
        if (commonLanguage == null) {
          commonLanguage = NONE;
        }
        if (commonType == null) {
          commonType = NONE;
        }
        if (!commonType.equals(NONE)) {
          typeOrLanguage = TYPE;
          typeOrLanguageValue = commonType;
        } else {
          typeOrLanguageValue = commonLanguage;
        }
      } else if ((value instanceof Map && ((Map) value).containsKey(GRAPH))) {
        if (((Map) value).containsKey(INDEX)) {
          containers.add(GRAPH + INDEX);
          containers.add(GRAPH + INDEX + SET);
        }
        if (((Map) value).containsKey(ID)) {
          containers.add(GRAPH + ID);
          containers.add(GRAPH + ID + SET);
        }
        containers.add(GRAPH);
        containers.add(GRAPH + SET);
        containers.add(SET);
        if (!((Map) value).containsKey(INDEX)) {
          containers.add(GRAPH + INDEX);
          containers.add(GRAPH + INDEX + SET);
        }
        if (!((Map) value).containsKey(ID)) {
          containers.add(GRAPH + ID);
          containers.add(GRAPH + ID + SET);
        }
        containers.add(INDEX);
        containers.add(INDEX + SET);
        typeOrLanguage = TYPE;
        typeOrLanguageValue = ID;
      } else {
        if ((value instanceof Map && ((Map) value).containsKey(VALUE))) {
          if ((((Map) value).containsKey(DIRECTION) && !((Map) value).containsKey(INDEX))) {
            typeOrLanguageValue = ((String) ((Map) value).getOrDefault(LANGUAGE, "")) + "_" + ((Map) value).get(DIRECTION);
            containers.add(LANGUAGE);
            containers.add(LANGUAGE + SET);
          } else if ((((Map) value).containsKey(LANGUAGE) && !((Map) value).containsKey(INDEX))) {
            typeOrLanguageValue = ((String) ((Map) value).get(LANGUAGE));
            containers.add(LANGUAGE);
            containers.add(LANGUAGE + SET);
          } else if (((Map) value).containsKey(TYPE)) {
            typeOrLanguageValue = ((String) ((Map) value).get(TYPE));
            typeOrLanguage = TYPE;
          }
        } else {
          typeOrLanguage = TYPE;
          typeOrLanguageValue = ID;
          containers.add(ID);
          containers.add(ID + SET);
          containers.add(TYPE);
          containers.add(SET + TYPE);
        }
        containers.add(SET);
      }
      containers.add(NONE);
      if (!activeContext.processingMode.equals(JSONLD10)) {
        if ((!(value instanceof Map) || !((Map) value).containsKey(INDEX))) {
          containers.add(INDEX);
          containers.add(INDEX + SET);
        }
      }
      if (!activeContext.processingMode.equals(JSONLD10)) {
        if ((value instanceof Map && ((Map) value).size() == 1 && ((Map) value).containsKey(VALUE))) {
          containers.add(LANGUAGE);
          containers.add(LANGUAGE + SET);
        }
      }
      if (typeOrLanguageValue == null) {
        typeOrLanguageValue = NULL;
      }
      List<String> preferredValues = new ArrayList<>();
      if ((typeOrLanguageValue == null && ((Object) REVERSE) == null || typeOrLanguageValue != null && (typeOrLanguageValue).equals(REVERSE))) {
        preferredValues.add(REVERSE);
      }
      if ((new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) ID, REVERSE}))).contains(typeOrLanguageValue) && value instanceof Map && ((Map) value).containsKey(ID))) {
        String compactId = (String) iriCompaction(activeContext, ((String) ((Map) value).get(ID)));
        /*@Nullable*/ Term idTerm = (/*@Nullable*/ Term) activeContext.terms.get(compactId);
        if ((idTerm != null && (idTerm.iri == null && ((Object) ((Map) value).get(ID)) == null || idTerm.iri != null && (idTerm.iri).equals(((Map) value).get(ID))))) {
          preferredValues.add(VOCAB);
          preferredValues.add(ID);
          preferredValues.add(NONE);
        } else {
          preferredValues.add(ID);
          preferredValues.add(VOCAB);
          preferredValues.add(NONE);
        }
      } else {
        preferredValues.add(typeOrLanguageValue);
        preferredValues.add(NONE);
        if ((value instanceof Map && ((Map) value).containsKey(LIST))) {
          List listvalue = (List) ((List) ((Map) value).get(LIST));
          if (listvalue.size() == 0) {
            typeOrLanguage = ANY;
          }
        }
      }
      preferredValues.add(ANY);
      for (String pv : ((List<String>) new ArrayList(preferredValues))) {
        Integer idx = (Integer) pv.indexOf("_");
        if (idx > -1) {
          preferredValues.add((pv.length() >= idx ? pv.substring(idx) : ""));
        }
      }
      /*@Nullable*/ String termKey = termSelection(activeContext, iri, containers, typeOrLanguage, preferredValues);
      if (termKey != null) {
        return termKey;
      }
    }
    if ((vocab && activeContext.vocabularyMapping != null)) {
      if (iri.startsWith(activeContext.vocabularyMapping)) {
        String suffix = (iri.length() >= activeContext.vocabularyMapping.length() ? iri.substring(activeContext.vocabularyMapping.length()) : "");
        if ((suffix.length() > 0 && !activeContext.terms.containsKey(suffix))) {
          return suffix;
        }
      }
    }
    /*@Nullable*/ String compactIri = null;
    for (Map.Entry<String, Term> key_termDfn : activeContext.terms.entrySet()) {
      String key = key_termDfn.getKey();
      Term termDfn = key_termDfn.getValue();
      if ((termDfn.iri == null || (termDfn.iri == null && ((Object) iri) == null || termDfn.iri != null && (termDfn.iri).equals(iri)) || !(iri.startsWith(termDfn.iri)) || !(termDfn.isPrefix))) {
        continue;
      }
      String candidate = key + ":" + (iri.length() >= termDfn.iri.length() ? iri.substring(termDfn.iri.length()) : "");
      if ((compactIri == null || (candidate.length() <= compactIri.length() && candidate.compareTo(compactIri) < 0))) {
        if ((!activeContext.terms.containsKey(candidate) || ((activeContext.terms.get(candidate).iri == null && ((Object) iri) == null || activeContext.terms.get(candidate).iri != null && (activeContext.terms.get(candidate).iri).equals(iri)) && value == null))) {
          compactIri = candidate;
        }
      }
    }
    if (compactIri != null) {
      return compactIri;
    }
    Integer colonx = (Integer) iri.indexOf(":");
    if ((colonx > -1 && !iri.contains("//"))) {
      /*@Nullable*/ Term term = activeContext.terms.get((iri.length() >= 0 ? iri.substring(0, colonx) : ""));
      if ((term != null && term.isPrefix)) {
        throw new IRIConfusedWithPrefixError(iri.toString());
      }
    }
    if (!(vocab)) {
      iri = relativiseIri(activeContext.baseIri, iri);
    }
    return iri;
  }
  public static /*@Nullable*/ String termSelection(Context activeContext, String keywordOrIri, List<String> containers, String typeOrLanguage, List<String> preferredValues) {
    Map inverseContext = (Map) getInverseContext(activeContext);
    Map<String, Object> containerMap = ((Map<String, Object>) inverseContext.get(keywordOrIri));
    for (String container : containers) {
      if (!containerMap.containsKey(container)) {
        continue;
      }
      Map<String, Object> typelanguageMap = ((Map<String, Object>) containerMap.get(container));
      Map<String, String> valueMap = ((Map<String, String>) typelanguageMap.get(typeOrLanguage));
      for (String item : preferredValues) {
        if (!valueMap.containsKey(item)) {
          continue;
        }
        return valueMap.get(item);
      }
    }
    return null;
  }
  public static Object valueCompaction(Context activeContext, /*@Nullable*/ Term activeTerm, Map<String, Object> value) {
    Object result = new HashMap(value);
    Map inverseContext = (Map) getInverseContext(activeContext);
    /*@Nullable*/ String language = (/*@Nullable*/ String) activeContext.defaultLanguage;
    if ((activeTerm != null && activeTerm.language != null)) {
      language = (String) activeTerm.language;
    }
    /*@Nullable*/ String direction = (/*@Nullable*/ String) activeContext.defaultBaseDirection;
    if ((activeTerm != null && activeTerm.direction != null)) {
      direction = (String) activeTerm.direction;
    }
    if (((value.containsKey(ID) && value.size() == 1) || (value.size() == 2 && value.containsKey(INDEX)))) {
      if ((activeTerm != null && (activeTerm.typeMapping == null && ((Object) ID) == null || activeTerm.typeMapping != null && (activeTerm.typeMapping).equals(ID)))) {
        result = (Object) shortenIri(activeContext, ((String) value.get(ID)));
      } else if ((activeTerm != null && (activeTerm.typeMapping == null && ((Object) VOCAB) == null || activeTerm.typeMapping != null && (activeTerm.typeMapping).equals(VOCAB)))) {
        result = (Object) iriCompaction(activeContext, ((String) value.get(ID)));
      }
    } else if ((activeTerm != null && value.containsKey(TYPE) && (value.get(TYPE) == null && ((Object) activeTerm.typeMapping) == null || value.get(TYPE) != null && (value.get(TYPE)).equals(activeTerm.typeMapping)))) {
      result = (Object) value.get(VALUE);
    } else if (((activeTerm != null && (activeTerm.typeMapping == null && ((Object) NONE) == null || activeTerm.typeMapping != null && (activeTerm.typeMapping).equals(NONE))) || (value.containsKey(TYPE) && (activeTerm == null || !value.get(TYPE).equals(activeTerm.typeMapping))))) {
      if ((result instanceof Map && ((Map) result).containsKey(TYPE))) {
        Object rtype = (Object) ((Map) result).get(TYPE);
        if (rtype instanceof List) {
          List<String> ctypes = new ArrayList<>();
          for (Object t : (List) rtype) {
            ctypes.add(iriCompaction(activeContext, ((String) t)));
          }
          ((Map) result).put(TYPE, ctypes);
        } else {
          ((Map) result).put(TYPE, iriCompaction(activeContext, ((String) rtype)));
        }
      }
    } else if ((value.containsKey(VALUE) && !(value.get(VALUE) instanceof String))) {
      if (((value.containsKey(INDEX) && activeTerm != null && activeTerm.container.contains(INDEX)) || !value.containsKey(INDEX))) {
        result = (Object) value.get(VALUE);
      }
    } else if ((value.containsKey(VALUE) && ((value.containsKey(LANGUAGE) && (value.get(LANGUAGE) == null && ((Object) language) == null || value.get(LANGUAGE) != null && (value.get(LANGUAGE)).equals(language))) || (NULLS.contains(language) && !value.containsKey(LANGUAGE))))) {
      if ((!value.containsKey(DIRECTION) || (direction != null && (value.get(DIRECTION) == null && ((Object) direction) == null || value.get(DIRECTION) != null && (value.get(DIRECTION)).equals(direction))))) {
        if ((!value.containsKey(INDEX) || (activeTerm != null && activeTerm.container.contains(INDEX)))) {
          result = (Object) value.get(VALUE);
        }
      }
    }
    if (result instanceof Map) {
      Map compacted = new HashMap<>();
      for (Map.Entry<String, Object> k_v : ((Map<String, Object>) result).entrySet()) {
        String k = k_v.getKey();
        Object v = k_v.getValue();
        compacted.put(iriCompaction(activeContext, k, v), v);
      }
      result = compacted;
    }
    return result;
  }
}
